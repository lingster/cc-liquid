{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>\u26a0\ufe0f PRE-ALPHA SOFTWARE - USE AT YOUR OWN RISK \u26a0\ufe0f</p> <ul> <li>Using this software may result in COMPLETE LOSS of funds</li> <li>CrowdCent makes NO WARRANTIES and assumes NO LIABILITY</li> <li>Users must comply with Hyperliquid terms of service</li> <li>We do NOT endorse any strategies using this tool</li> </ul> <p><code>cc-liquid</code> is a reference implementation for simple, automated portfolio rebalancing on Hyperliquid driven by metamodel predictions.</p> <p></p>"},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>Download CrowdCent or Numerai metamodel predictions</li> <li>Backtest strategies on historical data with comprehensive metrics \u26a0\ufe0f (requires your own price data)</li> <li>Optimize portfolio parameters using parallel grid search \u26a0\ufe0f (requires your own price data) </li> <li>Inspect account, positions, and exposure</li> <li>Rebalance to long/short target sets with equal-weight sizing</li> <li>Run continuously on a schedule (autopilot)</li> </ul>"},{"location":"#tldr","title":"TL;DR","text":"<pre><code>uv tool install cc-liquid\ncc-liquid init       # interactive setup wizard\ncc-liquid account    # test connection &amp; view positions\ncc-liquid analyze    # backtest with current settings\ncc-liquid optimize   # find optimal parameters\ncc-liquid rebalance  # plan and execute trades\ncc-liquid run        # run continuously on auto-pilot\n</code></pre> <p>See Install &amp; Quick Start for setup, environment variables, and first run. New users should try testnet first: <code>--set is_testnet=true</code>.</p> <p>Critical Disclaimers</p> <p>The <code>analyze</code> and <code>optimize</code> commands use historical data to test strategies. Remember that past performance does not predict future results. Backtesting has inherent limitations and optimized parameters are prone to overfitting. See backtesting documentation for important disclaimers.</p> <p>Past performance does not guarantee future results. Backtesting results are hypothetical and have inherent limitations:</p> <ul> <li>Overfitting Risk: Parameters that perform well historically may fail in live trading</li> <li>Market Dynamics: Conditions, liquidity, and correlations change over time</li> <li>Execution Reality: Slippage, fees, and market impact may exceed modeled estimates</li> <li>Survivorship Bias: Historical data may exclude delisted/failed assets</li> <li>Data Mining: Testing multiple strategies increases the chance of finding spurious patterns</li> </ul> <p>THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. USERS ASSUME ALL RISKS INCLUDING COMPLETE LOSS OF FUNDS, TRADING LOSSES, TECHNICAL FAILURES, AND LIQUIDATION RISKS.</p>"},{"location":"autopilot/","title":"Autopilot & Scheduling","text":"<p>Autopilot runs a live dashboard and executes rebalances on your schedule.</p>"},{"location":"autopilot/#run-autopilot","title":"Run autopilot","text":"<pre><code>cc-liquid run --skip-confirm\n</code></pre> <p>Live dashboard (monitor):</p> <p></p> <p>Flags:</p> <ul> <li><code>--skip-confirm</code>: execute without confirmation when due</li> <li><code>--tmux</code>: run monitor within a tmux session/window</li> <li><code>--set</code>: override config at runtime</li> <li><code>--refresh</code>: UI refresh cadence in seconds (default 1.0)</li> </ul> <p>Run inside tmux (advanced)</p> <p>For long-running sessions, you can run the dashboard in a fixed tmux session. This will attach to the session if it already exists, or create it and start the loop if not.</p> <p>Start (or attach) with uv:</p> <pre><code>uv run cc-liquid run --tmux --skip-confirm\n</code></pre> <ul> <li>Detach with Ctrl-B and continue using your machine. </li> <li>Re-attach later: <code>tmux attach -t cc-liquid</code> or <code>cc-liquid run --tmux</code></li> <li>Stop the loop with Ctrl-C. The session stays open until you exit/kill it.</li> </ul>"},{"location":"autopilot/#schedule","title":"Schedule","text":"<p>Configure in <code>cc-liquid-config.yaml</code>:</p> <pre><code>portfolio:\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"   # UTC\n</code></pre> <p>The next time is computed from the last successful rebalance timestamp, stored in <code>.cc_liquid_state.json</code>.</p> <p>State details:</p> <ul> <li>The file stores <code>last_rebalance_date</code> as ISO-8601 UTC.</li> <li>If no state is present, the next run is scheduled for today at <code>portfolio.rebalancing.at_time</code> (or immediately if already past).</li> <li>Each successful cycle updates the timestamp.</li> </ul>"},{"location":"backtesting/","title":"Backtesting & Optimization","text":"<p>Critical Disclaimer</p> <p>Past performance does not guarantee future results. Backtesting results are hypothetical and have inherent limitations:</p> <ul> <li>Overfitting Risk: Parameters that perform well historically may fail in live trading</li> <li>Market Dynamics: Conditions, liquidity, and correlations change over time</li> <li>Execution Reality: Slippage, fees, and market impact may exceed modeled estimates</li> <li>Survivorship Bias: Historical data may exclude delisted/failed assets</li> <li>Data Mining: Testing multiple strategies increases the chance of finding spurious patterns</li> </ul> <p>Always validate strategies with out-of-sample data, paper trading, and start with minimal capital when going live.</p> <p>Test your strategies on historical data before risking real capital. cc-liquid provides powerful backtesting tools to analyze performance and optimize parameters.</p> <p>Data Requirements</p> <p>You need to bring your own datasets for backtesting. cc-liquid requires two data files:</p> <ol> <li>Historical price data (<code>raw_data.parquet</code>) - Daily closing prices for all assets</li> <li>Historical predictions (<code>predictions.parquet</code>) - Your prediction scores/signals for each asset</li> </ol> <p>See Data requirements section below for detailed format specifications.</p>"},{"location":"backtesting/#quick-start","title":"Quick start","text":""},{"location":"backtesting/#basic-backtest","title":"Basic backtest","text":"<p>Once you have prepared your data files, run a backtest with your current configuration:</p> <pre><code># Ensure you have these files in your working directory:\n# - raw_data.parquet (price history)  \n# - predictions.parquet (your signals)\n\ncc-liquid analyze\n</code></pre> <p>This uses price data from <code>raw_data.parquet</code> (must exist), predictions from <code>predictions.parquet</code> or your configured data source, and portfolio settings from <code>cc-liquid-config.yaml</code>.</p>"},{"location":"backtesting/#parameter-optimization","title":"Parameter optimization","text":"<p>Find optimal portfolio parameters using grid search:</p> <pre><code>cc-liquid optimize\n</code></pre>"},{"location":"backtesting/#analyze-command","title":"Analyze command","text":"<p>The <code>analyze</code> command runs a single backtest with specified parameters.</p>"},{"location":"backtesting/#basic-usage","title":"Basic usage","text":"<pre><code># Use config defaults\ncc-liquid analyze\n\n# Override specific parameters\ncc-liquid analyze --set portfolio.num_long=15 --set portfolio.num_short=5 --set portfolio.target_leverage=2.0\n\n# Custom date range\ncc-liquid analyze --start-date 2024-01-01 --end-date 2024-06-30\n\n# Switch prediction column and rebalancing parameters\ncc-liquid analyze --set data.prediction_column=pred_10d --set portfolio.rebalancing.every_n_days=10\n\n# Show position details and save daily results\ncc-liquid analyze --show-positions --save-daily results.csv\n</code></pre>"},{"location":"backtesting/#parameters","title":"Parameters","text":"Parameter Default Description <code>--prices</code> <code>raw_data.parquet</code> Path to historical price data <code>--start-date</code> Auto Backtest start date (YYYY-MM-DD) <code>--end-date</code> Auto Backtest end date (YYYY-MM-DD) <code>--set</code> None Override config values (e.g., <code>--set portfolio.num_long=15</code>) <code>--fee-bps</code> 4.0 Trading fees in basis points <code>--slippage-bps</code> 50.0 Slippage costs in basis points <code>--show-positions</code> False Show detailed position data <code>--save-daily</code> None Save daily returns to CSV <code>--verbose</code> False Show detailed progress"},{"location":"backtesting/#output-metrics","title":"Output metrics","text":"<p>The backtest displays comprehensive performance metrics including total return and CAGR, volatility and max drawdown, risk-adjusted metrics (Sharpe, Sortino, Calmar ratios), trading statistics (win rate, turnover), and final equity value.</p> <p>Example output:</p> <p></p>"},{"location":"backtesting/#optimize-command","title":"Optimize command","text":"<p>Optimization Warning</p> <p>Parameter optimization is particularly susceptible to overfitting. The more parameters and combinations you test, the higher the risk of finding parameters that only work historically. Always reserve out-of-sample data for validation, test parameter stability across different periods, be skeptical of unrealistic returns, and consider transaction costs and market impact.</p> <p>The <code>optimize</code> command runs parallel grid search to find optimal parameters.</p>"},{"location":"backtesting/#basic-usage_1","title":"Basic usage","text":"<pre><code># Requires raw_data.parquet and predictions.parquet to exist\n# Default optimization\ncc-liquid optimize\n\n# Custom parameter ranges\ncc-liquid optimize \\\n  --num-longs \"10,20,30\" \\\n  --num-shorts \"0,5,10\" \\\n  --leverages \"1.0,2.0,3.0\" \\\n  --rebalance-days \"7,14,21\" \\\n  --rank-powers \"0.0,0.5,1.0,1.5,2.0\"\n\n# Optimize for specific metric\ncc-liquid optimize --metric calmar\n\n# Apply drawdown constraint\ncc-liquid optimize --max-drawdown 0.20  # Max 20% drawdown\n\n# Run best parameters immediately\ncc-liquid optimize --apply-best\n</code></pre>"},{"location":"backtesting/#parameters_1","title":"Parameters","text":"Parameter Default Description <code>--prices</code> <code>raw_data.parquet</code> Path to historical price data <code>--set</code> None Override config values (e.g., <code>--set data.source=numerai</code>) <code>--num-longs</code> \"10,20,30,40,50\" Long positions to test <code>--num-shorts</code> \"10,20,30,40,50\" Short positions to test <code>--leverages</code> \"1.0,2.0,3.0,4.0,5.0\" Leverage levels to test <code>--rebalance-days</code> \"8,10,12\" Rebalance frequencies to test <code>--rank-powers</code> \"0.0,0.5,1.0,1.5,2.0\" Rank power values to test (0=equal weight) <code>--metric</code> sharpe Optimization target: sharpe, cagr, calmar <code>--max-drawdown</code> None Maximum drawdown constraint <code>--top-n</code> 20 Show top N results <code>--apply-best</code> False Run full analysis with best params <code>--save-results</code> None Save results to CSV <code>--plot</code> False Show contour plots <code>--max-workers</code> Auto Parallel workers (default: CPU count) <code>--clear-cache</code> False Clear optimization cache <code>--verbose</code> False Show detailed progress"},{"location":"backtesting/#optimization-metrics","title":"Optimization metrics","text":"<p>Choose your optimization target based on your goals: sharpe for best risk-adjusted returns (default), cagr for maximum absolute returns, or calmar for best returns relative to drawdown.</p> <p>Position Weighting in Optimization</p> <p>The optimizer tests different position weighting concentrations using <code>--rank-powers</code>. All optimizations use the <code>rank_power</code> scheme where:</p> <ul> <li><code>0.0</code> = equal weighting (all positions same size)</li> <li><code>0.5-1.0</code> = mild concentration in top-ranked positions</li> <li><code>1.5-2.0</code> = moderate concentration</li> <li><code>2.0+</code> = heavy concentration</li> </ul> <p>This replaces the need for a separate <code>weighting_scheme</code> parameter. See Portfolio Weighting for visual explanations of concentration effects.</p>"},{"location":"backtesting/#parallel-execution","title":"Parallel execution","text":"<p>The optimizer uses multiprocessing to test parameter combinations in parallel. It automatically detects CPU cores (capped at 24), caches results to speed up repeated runs, and shows real-time progress with best parameters found.</p> <p>Example output:</p> <p></p>"},{"location":"backtesting/#caching","title":"Caching","text":"<p>Results are cached in <code>.cc_liquid_optimizer_cache.json</code> to speed up repeated optimizations and preserve results across sessions. Clear with the <code>--clear-cache</code> flag when needed.</p>"},{"location":"backtesting/#applying-best-parameters","title":"Applying best parameters","text":"<p>After optimization, apply the best parameters:</p> <pre><code># Option 1: Run immediately\ncc-liquid optimize --apply-best\n\n# Option 2: Update config manually\n# Copy best parameters from output to cc-liquid-config.yaml\n</code></pre>"},{"location":"backtesting/#data-requirements","title":"Data requirements","text":"<p>Bring Your Own Data</p> <p>cc-liquid does not provide historical data. You must source your own price history and prediction signals for backtesting.</p>"},{"location":"backtesting/#price-data-raw_dataparquet","title":"Price data (<code>raw_data.parquet</code>)","text":"<p>Historical daily price data for all assets you want to trade. This file must contain:</p> Column Type Description Example <code>date</code> datetime Price observation date 2024-01-15 <code>id</code> string Asset identifier (must match Hyperliquid symbols) \"BTC\", \"ETH\", \"SOL\" <code>close</code> float Closing price in USD 42500.00 <p>Example structure: <pre><code># DataFrame should look like:\n#        date    id      close\n# 0  2024-01-01  BTC   42000.00\n# 1  2024-01-01  ETH    2250.00\n# 2  2024-01-01  SOL      95.50\n# 3  2024-01-02  BTC   43500.00\n# ...\n</code></pre></p> <p>Data requirements:</p> <ul> <li>Must cover the full backtest period for all assets</li> <li>Daily frequency (one price per asset per day)</li> <li>Asset IDs must exactly match Hyperliquid ticker symbols</li> <li>Prices should be in USD</li> <li>Can include more assets than you have predictions for (extras will be ignored)</li> </ul>"},{"location":"backtesting/#advanced-usage","title":"Advanced usage","text":""},{"location":"backtesting/#custom-data-sources","title":"Custom data sources","text":"<p>Test with different prediction files or prediction timeframes:</p> <pre><code># Test Numerai predictions\ncc-liquid analyze --set data.source=numerai\n\n# Test 10d predictions\ncc-liquid analyze --set data.prediction_column=pred_10d\n</code></pre>"},{"location":"backtesting/#cost-analysis","title":"Cost analysis","text":"<p>Adjust trading costs:</p> <pre><code>cc-liquid analyze --fee-bps 5 --slippage-bps 10\n</code></pre>"},{"location":"backtesting/#red-flags","title":"Red flags","text":"<p>Watch for signs of overfitting:</p> <ul> <li>Sharpe ratio &gt; 3 (too good to be true?)</li> <li>Performance degrades sharply outside optimum</li> <li>Large discrepancy between periods</li> <li>Performance doesn't generalize when adding prediction-lags</li> </ul> <p>Disclaimer</p> <p>Past performance does not guarantee future results. Backtests are simplified models that may not capture all market dynamics, execution challenges, or black swan events.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>cc-liquid loads configuration from <code>cc-liquid-config.yaml</code> and environment variables. Addresses, profile selection, and portfolio parameters live in the config YAML; secrets (private keys, API keys) should live in <code>.env</code>. You can override any setting via <code>--set</code> when running the CLI commands.</p>"},{"location":"configuration/#environment-variables-env","title":"Environment variables (.env)","text":"<p>Your env file, which should only store secrets/keys should look like this:</p> <pre><code>CROWDCENT_API_KEY=zzxFake.CrowdCentKey1234567890   # (needed for CrowdCent metamodel source)\nHYPERLIQUID_PRIVATE_KEY=0xdeadbeefdeadbeefdeadbeefdeadbeefdead  # (default signer key variable name)\n</code></pre> <p>Note</p> <ul> <li> <p>You can change the default signer key variable name and provide additional, profile-specific signer keys you can reference via <code>signer_env</code> in YAML, (e.g.:<code>HYPER_AGENT_KEY_PERSONAL</code>, <code>HYPER_AGENT_KEY_VAULT</code>)</p> </li> <li> <p>Do not put addresses in <code>.env</code>; keep owner/vault addresses in the configuration YAML file.</p> </li> </ul> <p>Loading .env variables</p> <p>When <code>cc-liquid</code> is installed as a CLI tool (e.g., via <code>uv tool install</code>), it may not automatically load variables from <code>.env</code>. If you encounter errors about missing keys, you must load them manually in your shell session: <pre><code>export $(grep -v '^#' .env | xargs)\n</code></pre></p>"},{"location":"configuration/#yaml-cc-liquid-configyaml","title":"YAML (<code>cc-liquid-config.yaml</code>)","text":"<p>Your yaml file, in the root of where you call <code>cc-liquid</code> should look like this: <pre><code>is_testnet: false\n\nactive_profile: default\n\nprofiles:\n  default:\n    owner: 0xYourMain\n    vault: null                 # omit or null for personal portfolio\n    signer_env: HYPERLIQUID_PRIVATE_KEY\n\n  alternate-profile: # optional, informational\n    owner: 0xYourMain           \n    vault: 0xVaultAddress\n    signer_env: HYPERLIQUID_AGENT_KEY_VAULT\n\n\ndata:\n  source: crowdcent | numerai | local\n  path: predictions.parquet\n  date_column: release_date | date\n  asset_id_column: id | symbol\n  prediction_column: pred_10d | meta_model\n\nportfolio:\n  num_long: 10\n  num_short: 10\n  target_leverage: 1.0\n  rank_power: 0.0\n  stop_loss:\n    sides: none                # \"none\", \"both\", \"long_only\", \"short_only\"\n    pct: 0.17                  # 17% from entry price\n    slippage: 0.05             # 5% slippage tolerance\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"   # HH:MM (UTC)\n\nexecution:\n  slippage_tolerance: 0.005      # Market orders: aggressive pricing (default: 0.005)\n  limit_price_offset: 0.0        # Limit orders: passive offset (default: 0.0 = exact mid)\n  min_trade_value: 10.0\n  order_type: market | limit\n  time_in_force: Ioc | Gtc | Alo\n</code></pre></p>"},{"location":"configuration/#profiles-network-credentials","title":"Profiles, network &amp; credentials","text":"<ul> <li><code>profiles</code> define who you trade for and which key signs.</li> <li><code>owner</code>: portfolio owner (used for Info queries when <code>vault</code> not set)</li> <li><code>vault</code>: optional; when set, becomes the portfolio owner for Info and Exchange endpoint includes <code>vaultAddress</code></li> <li><code>signer_env</code>: name of env var holding the private key for signing</li> <li><code>active_profile</code> selects the default profile, override with <code>set --active_profile</code> at runtime</li> <li><code>is_testnet: true</code> switches from mainnet to testnet</li> </ul> <p>See more on how to generate Hyperliquid API wallets and private keys for safety: https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/nonces-and-api-wallets</p>"},{"location":"configuration/#data","title":"Data","text":"<p>Source types; columns can be overridden):</p>"},{"location":"configuration/#crowdcent","title":"crowdcent","text":"<pre><code>cc-liquid rebalance --set data.source=crowdcent\n</code></pre> <p>Defaults: <code>date_column=release_date</code>, <code>asset_id_column=id</code>, <code>prediction_column=pred_10d</code>, <code>path=predictions.parquet</code></p>"},{"location":"configuration/#numerai","title":"numerai","text":"<p>Ensure you have installed extras: <code>uv pip install cc-liquid[numerai]</code></p> <pre><code>cc-liquid rebalance --set data.source=numerai\n</code></pre> <p>Defaults: <code>date_column=date</code>, <code>asset_id_column=symbol</code>, <code>prediction_column=meta_model</code>, <code>path=predictions.parquet</code></p> <p>Tip</p> <p>Running commands with <code>--set data.source=numerai</code> can auto-apply column defaults for the Numerai metamodel.</p>"},{"location":"configuration/#local","title":"local","text":"<p>Bring your own Parquet/CSV:</p> <pre><code>cc-liquid rebalance \\\n  --set data.source=local \\\n  --set data.path=my_preds.parquet \\\n  --set data.date_column=dt \\\n  --set data.asset_id_column=ticker \\\n  --set data.prediction_column=score\n</code></pre> <p>Column rules:</p> <ul> <li><code>date_column</code>: latest row per asset is used</li> <li><code>asset_id_column</code>: must match Hyperliquid symbols; unmatched are skipped</li> <li><code>prediction_column</code>: ranking for longs/shorts grouped by date</li> </ul>"},{"location":"configuration/#portfolio","title":"Portfolio","text":"<ul> <li><code>num_long</code> / <code>num_short</code>: counts for top/bottom selections</li> <li><code>target_leverage</code>: scales notional per-position like <code>(account_value * target_leverage) / (num_long + num_short)</code>.</li> <li><code>rank_power</code>: concentration parameter (0.0 = equal weight, default; higher = more concentration in top-ranked positions) - see Portfolio Weighting</li> <li><code>rebalancing.every_n_days</code> / <code>rebalancing.at_time</code> (UTC)</li> </ul>"},{"location":"configuration/#stop-loss-protection","title":"Stop Loss Protection","text":"<p>Stop losses protect your positions from adverse price moves using Hyperliquid's native TP/SL trigger orders. They're calculated from entry price (not current price) for consistent risk management.</p> <p>Configuration:</p> <ul> <li><code>stop_loss.sides</code>: which positions to protect<ul> <li><code>none</code> (default): no stop loss protection</li> <li><code>both</code>: protect all positions (longs and shorts)</li> <li><code>long_only</code>: protect only long positions</li> <li><code>short_only</code>: protect only short positions</li> </ul> </li> <li><code>stop_loss.pct</code>: trigger distance from entry price (default: 0.17 = 17%)<ul> <li>For longs: triggers when price falls 17% below entry</li> <li>For shorts: triggers when price rises 17% above entry</li> </ul> </li> <li><code>stop_loss.slippage</code>: slippage tolerance for the limit order (default: 0.05 = 5%)<ul> <li>Controls how far from trigger price the limit order can fill</li> <li>Higher = more likely to fill but worse execution</li> <li>Lower = better execution but may not fill in fast moves</li> </ul> </li> </ul> <p>How it works:</p> <ol> <li>After each rebalance, stop losses are automatically placed on all eligible open positions</li> <li>Stop losses use Hyperliquid's position-based TP/SL (not order-based OCO)</li> <li>Existing TP/SL orders are cancelled and replaced with fresh ones each rebalance</li> <li>Stop losses remain active until:</li> <li>Triggered by price move (position closes with slippage)</li> <li>Next rebalance (cancelled and replaced with new stops)</li> <li>Manually cancelled</li> </ol> <p>Manual application:</p> <p>For positions opened manually or when limit orders fill after rebalance:</p> <pre><code># Apply stop losses to all eligible open positions\ncc-liquid apply-stops\n\n# Override sides temporarily\ncc-liquid apply-stops --set portfolio.stop_loss.sides=both\n</code></pre>"},{"location":"configuration/#execution","title":"Execution","text":"<ul> <li><code>slippage_tolerance</code>: For market orders - calculates aggressive limit prices away from mid to ensure fills (buy above mid, sell below mid). Default: 0.005 (0.5%)</li> <li><code>limit_price_offset</code>: For limit orders - calculates passive prices inside mid for better execution (buy below mid, sell above mid). Default: 0.0 (exact mid). Higher values = further inside mid = better prices but lower fill probability.</li> <li><code>min_trade_value</code>: trades below this absolute USD delta are skipped</li> <li><code>order_type</code>: order execution method<ul> <li><code>market</code> (default): uses <code>slippage_tolerance</code> for aggressive fills away from mid</li> <li><code>limit</code>: uses <code>limit_price_offset</code> for passive pricing (0.0 = exact mid, &gt;0 = inside mid)</li> </ul> </li> <li><code>time_in_force</code>: how long orders stay active<ul> <li><code>Ioc</code> (Immediate or Cancel, default): fills immediately or cancels, no orders stay on book</li> <li><code>Gtc</code> (Good til Canceled): orders stay on book until filled or manually canceled</li> <li><code>Alo</code> (Add Liquidity Only): only posts to book, never takes liquidity</li> </ul> </li> </ul> <p>Note on limit orders with Ioc: Passive limit orders (priced at or inside mid) with Ioc may not fill immediately. Consider using <code>Gtc</code> or <code>Alo</code> for limit orders if you want orders to rest on the book.</p>"},{"location":"configuration/#order-status","title":"Order Status","text":"<p>When orders execute, they can have different outcomes:</p> <ul> <li>Filled - Order executed immediately \u2705</li> <li>Resting - Order successfully posted to book and waiting (Gtc/Alo only) \u2705</li> <li>Failed - Order rejected or not filled \u274c</li> </ul>"},{"location":"configuration/#managing-open-orders","title":"Managing Open Orders","text":"<p>When using <code>Gtc</code> or <code>Alo</code>, unfilled orders stay on the book. Use these commands to manage them:</p> <pre><code># View current open orders\ncc-liquid orders\n\n# Cancel all open orders\ncc-liquid cancel-orders\n\n# Cancel orders for specific coin\ncc-liquid cancel-orders --coin BTC\n\n# Cancel orders before rebalancing\ncc-liquid rebalance --cancel-open-orders\n</code></pre> <p>If you rebalance while having open orders, cc-liquid will: 1. Warn you about potential conflicts 2. Prompt you to cancel them (interactive) 3. Or you can use <code>--cancel-open-orders</code> flag to auto-cancel</p>"},{"location":"configuration/#view-trade-history","title":"View Trade History","text":"<p>Track your fills and fees:</p> <pre><code># Last 7 days\ncc-liquid history --days 7\n\n# Specific date range\ncc-liquid history --start 2025-01-01 --end 2025-01-31\n\n# Limit results\ncc-liquid history --limit 100\n</code></pre> <p>Shows execution price, size, fees, and realized PnL for each fill.</p>"},{"location":"configuration/#cli-overrides","title":"CLI overrides","text":"<p>Examples:</p> <pre><code>cc-liquid run --set active_portfolio=default\n</code></pre> <pre><code>cc-liquid rebalance --set data.source=numerai --set portfolio.target_leverage=2.0 --set portfolio.num_long=12\n</code></pre> <p>Nested keys use dot-notation. Types are inferred (int/float/bool/str).</p> <p>Smart defaults when switching <code>data.source</code> are applied unless explicitly overridden.</p>"},{"location":"configuration/#cli-helpers","title":"CLI helpers","text":"<ul> <li><code>cc-liquid profile list | show | use &lt;name&gt;</code> \u2013 manage profiles</li> <li><code>cc-liquid orders</code> \u2013 view current open orders</li> <li><code>cc-liquid cancel-orders [--coin SYMBOL]</code> \u2013 cancel open orders</li> <li><code>cc-liquid apply-stops</code> \u2013 manually apply stop losses to all open positions</li> <li><code>cc-liquid history [--days N | --start DATE --end DATE]</code> \u2013 view trade history and fees</li> </ul>"},{"location":"headless/","title":"Headless & Custom Callbacks","text":"<p>For advanced use cases or building alternative UIs, you can also use cc-liquid as a library without the CLI UI. The core trading logic is UI-agnostic and driven by callbacks. </p>"},{"location":"headless/#architecture","title":"Architecture","text":"<p>cc-liquid follows a modular design:</p> <ul> <li>Data Layer - Loads predictions from various sources (CrowdCent API, Numerai, local files)</li> <li>Strategy Layer - Selects top/bottom assets and calculates equal-weight position sizes</li> <li>Execution Layer - Interfaces with Hyperliquid via SDK for order management</li> <li>Monitoring Layer - Provides live dashboard and scheduled rebalancing (managed via callbacks and alternative UI code)</li> </ul>"},{"location":"headless/#callback-protocol","title":"Callback protocol","text":"<ul> <li>Implement <code>cc_liquid.callbacks.CCLiquidCallbacks</code> to receive lifecycle events (info/warn/error, trade start/fill/fail, batch complete, confirmation prompts, etc.).</li> <li>Use <code>cc_liquid.callbacks.NoOpCallbacks</code> to run headless without output, or <code>cc_liquid.cli_callbacks.RichCLICallbacks</code> for the rich TUI.</li> </ul>"},{"location":"headless/#programmatic-usage","title":"Programmatic usage","text":"<p>Minimal headless run with your own predictions:</p> <pre><code>import polars as pl\nfrom cc_liquid.config import Config\nfrom cc_liquid.trader import CCLiquid\nfrom cc_liquid.callbacks import NoOpCallbacks\n\n# Load env + YAML; apply any config file you have in cwd\ncfg = Config()\n\n# Example: use a local parquet with your own column names\npreds = pl.read_parquet(\"predictions.parquet\")\n\nbot = CCLiquid(cfg, callbacks=NoOpCallbacks())\n\n# Compute plan using provided predictions (skips loading by source)\nplan = bot.plan_rebalance(predictions=preds)\n\n# Inspect or modify plan[\"trades\"] as needed, then execute\nresult = bot.execute_plan(plan)\nprint({\n    \"num_success\": len(result[\"successful_trades\"]),\n    \"num_total\": len(result[\"all_trades\"]),\n})\n</code></pre> <p>Notes:</p> <ul> <li>If you let the bot load predictions, set <code>cfg.data.source</code> and related columns first.</li> <li>Trades below <code>execution.min_trade_value</code> are reported in <code>plan[\"skipped_trades\"]</code>.</li> </ul>"},{"location":"headless/#scheduling-without-cli","title":"Scheduling (without CLI)","text":"<p>The bot exposes helpers for simple scheduling and state persistence:</p> <pre><code>from datetime import UTC, datetime\n\nlast = bot.load_state()  # reads .cc_liquid_state.json if present\nnext_time = bot.compute_next_rebalance_time(last)\nif datetime.now(UTC) &gt;= next_time:\n    plan = bot.plan_rebalance()\n    res = bot.execute_plan(plan)\n    bot.save_state(datetime.now(UTC))\n</code></pre>"},{"location":"install-quickstart/","title":"Install & Quick Start","text":""},{"location":"install-quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Hyperliquid API/Agent wallet (address + private key)</li> <li>Optional: CrowdCent API key</li> </ul>"},{"location":"install-quickstart/#install","title":"Install","text":"<p>If uv is not yet installed:</p> macOS / LinuxWindows (PowerShell) <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>"},{"location":"install-quickstart/#install-cc-liquid-as-a-cli-tool","title":"Install cc-liquid as a CLI tool:","text":"<pre><code>uv tool install cc-liquid\nuv tool install cc-liquid[numerai] # optional Numerai support\n</code></pre>"},{"location":"install-quickstart/#or-run-with-uvx-no-install","title":"Or run with uvx (no install)","text":"<pre><code>uvx cc-liquid init\n</code></pre>"},{"location":"install-quickstart/#first-time-setup","title":"First-time setup","text":"<pre><code>cc-liquid init               # interactive setup wizard (recommended)\ncc-liquid init --non-interactive  # use safe defaults without prompts\n</code></pre> <p>The wizard will guide you through:</p> <ul> <li>Choosing testnet vs mainnet (defaults to testnet for safety)</li> <li>Selecting data source (CrowdCent, Numerai, or local)</li> <li>Entering API keys (with links to get them)</li> <li>Setting up portfolio parameters</li> <li>Auto-adding <code>.env</code> to <code>.gitignore</code> for security</li> </ul> <p>Example init result:</p> <p></p> <p>Warning</p> <p>Before running commands, your secrets must be loaded into your shell's environment. <code>cc-liquid</code> will attempt to load any .env in PATH, but if you are encountering errors it is likely that you need to manually export your environment variables. From the directory with your .env, run either:</p> <p>1) export the file to a UV environment variable <pre><code>export UV_ENV_FILE=.env\n</code></pre></p> <p>or 2) export all non-comments in .env <pre><code>export $(grep -v '^#' .env | xargs)\n</code></pre></p> <p>You'll need to run it in each new terminal session.</p>"},{"location":"install-quickstart/#enable-tab-auto-completion-in-your-shell-optional","title":"Enable tab auto-completion in your shell (optional)","text":"<p>Tabs for commands, options, and values.</p> <pre><code>cc-liquid completion install          # auto-detects your shell\n</code></pre> <p>Manual equivalent:</p> BashZshFish <pre><code>_CC_LIQUID_COMPLETE=bash_source cc-liquid &gt; ~/.cc-liquid-complete.bash\necho '. ~/.cc-liquid-complete.bash' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>_CC_LIQUID_COMPLETE=zsh_source cc-liquid &gt; ~/.cc-liquid-complete.zsh\necho '. ~/.cc-liquid-complete.zsh' &gt;&gt; ~/.zshrc\n</code></pre> <pre><code>mkdir -p ~/.config/fish/completions\n_CC_LIQUID_COMPLETE=fish_source cc-liquid &gt; ~/.config/fish/completions/cc-liquid.fish\n</code></pre> <p>Restart your shell to activate completion, or run <code>source ~/.bashrc</code>, <code>source ~/.zshrc</code>, etc. as needed. See Click Shell Completion for details.</p>"},{"location":"install-quickstart/#quick-start","title":"Quick Start","text":""},{"location":"install-quickstart/#configure","title":"Configure","text":"<p>View configuration for full configuration details. After running <code>cc-liquid init</code>, you'll have two files:</p> <p>1) <code>.env</code> - Contains your secrets (auto-added to .gitignore):</p> <pre><code># Secrets only - NEVER commit this file to git!\nCROWDCENT_API_KEY=...                # from https://crowdcent.com/profile\nHYPERLIQUID_PRIVATE_KEY=0x...        # from https://app.hyperliquid.xyz/API\n</code></pre> <p>2) <code>cc-liquid-config.yaml</code> - Your trading configuration:</p> <pre><code>active_profile: personal\n\nprofiles:\n  personal:\n    owner: 0xYourMain\n    vault: null\n    signer_env: HYPER_AGENT_KEY_PERSONAL\n\ndata:\n  source: crowdcent         # crowdcent | numerai | local\n  path: predictions.parquet\n  date_column: release_date\n  asset_id_column: id\n  prediction_column: pred_10d\n\nportfolio:\n  num_long: 10\n  num_short: 10\n  target_leverage: 1.0\n  rebalancing:\n    every_n_days: 10\n    at_time: \"18:15\"\n\nexecution:\n  slippage_tolerance: 0.005\n</code></pre>"},{"location":"install-quickstart/#first-run","title":"First run","text":"<pre><code>cc-liquid config     # verify config is loaded\ncc-liquid account    # view account and positions\ncc-liquid rebalance  # plan and execute trades (prompts for confirmation)\n</code></pre>"},{"location":"install-quickstart/#autopilot-continuous","title":"Autopilot (continuous)","text":"<p>Runs a live dashboard and executes on your schedule.</p> <pre><code>cc-liquid run --skip-confirm   # WARNING: executes trades automatically\n</code></pre> <p>See the User Guide for a deeper walkthrough.</p>"},{"location":"portfolio-weighting/","title":"Portfolio Weighting","text":"<p>cc-liquid uses rank power position sizing to control how capital is distributed across positions. By adjusting a single <code>rank_power</code> parameter, you can range from equal weighting (all positions same size) to heavy concentration in your highest-conviction positions.</p>"},{"location":"portfolio-weighting/#visual-overview","title":"Visual Overview","text":""},{"location":"portfolio-weighting/#example-schemes-impact-on-position-sizing","title":"Example schemes impact on position sizing","text":"<p>The grid above shows how three different weighting schemes distribute capital across long and short positions in various portfolio configurations. Notice how rank power creates concentration in top-ranked positions while maintaining the target leverage.</p>"},{"location":"portfolio-weighting/#concentration-effects","title":"Concentration Effects","text":"<p>These curves demonstrate how the rank power parameter controls concentration:</p> <ul> <li>Power = 0.0 (equal weight, default): All positions get the same allocation</li> <li>Power = 0.5-1.0: Mild concentration favoring top positions  </li> <li>Power = 1.5-2.0: Moderate concentration</li> <li>Power = 3.0+: Heavy concentration in top few positions</li> </ul>"},{"location":"portfolio-weighting/#configuration","title":"Configuration","text":""},{"location":"portfolio-weighting/#yaml-configuration","title":"YAML Configuration","text":"<pre><code>portfolio:\n  num_long: 60\n  num_short: 50\n  target_leverage: 4.0\n  rank_power: 0.0  # 0.0 = equal weight (default), higher = more concentration\n</code></pre>"},{"location":"portfolio-weighting/#cli-override","title":"CLI Override","text":"<pre><code># Equal weight (default)\ncc-liquid analyze --set portfolio.rank_power=0.0\n\n# Moderate concentration\ncc-liquid analyze --set portfolio.rank_power=1.5\n\n# Heavy concentration for live trading\ncc-liquid rebalance --set portfolio.rank_power=2.0\n</code></pre>"},{"location":"portfolio-weighting/#how-rank-power-works","title":"How Rank Power Works","text":"<p>Positions are weighted using the formula <code>(rank/n)^power</code>, where:</p> <ul> <li><code>rank</code> is the position's rank within its side (1 = best)</li> <li><code>n</code> is the total number of positions on that side</li> <li><code>power</code> is your concentration parameter</li> </ul> <p>Key insight: When <code>power = 0.0</code>, the formula <code>(rank/n)^0 = 1.0</code> for all ranks, producing equal weighting. As you increase power, top-ranked positions (stronger signals) receive progressively more capital.</p>"},{"location":"portfolio-weighting/#examples","title":"Examples","text":"<pre><code># Equal weighting (default)\nrank_power: 0.0\n\n# Mild concentration\nrank_power: 0.5\n\n# Moderate concentration\nrank_power: 1.5\n\n# Heavy concentration\nrank_power: 2.5\n</code></pre>"},{"location":"security/","title":"Security & Disclaimer","text":"<p>Keep secrets safe and understand the risks.</p>"},{"location":"security/#secrets-hygiene","title":"Secrets hygiene","text":"<ul> <li>Store keys only in a local <code>.env</code> file (see Install &amp; Quick Start \u2192 Configure and Configuration \u2192 Environment variables)</li> <li>Never commit <code>.env</code> (already gitignored)</li> <li>Use a dedicated API/Agent wallet separate from main funds</li> </ul>"},{"location":"security/#operational-risk","title":"Operational risk","text":"<ul> <li>Autopilot can execute trades automatically (<code>--skip-confirm</code>) (see Autopilot &amp; Scheduling)</li> <li>Leverage increases risk of liquidation</li> <li>Network/API failures can cause missed or partial rebalances</li> </ul>"},{"location":"security/#legal-disclaimer","title":"Legal disclaimer","text":"<p>THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>This is PRE-ALPHA software intended as a reference implementation only. Users assume ALL risks associated with using this software, including but not limited to: - Complete loss of funds - Trading losses - Technical failures - Liquidation risks - Any other financial losses</p> <p>CrowdCent does not endorse, recommend, or provide support for any trading strategies, vaults, or implementations using this software. Users must independently verify all functionality and assume full responsibility for their trading decisions.</p> <p>By using this software, you agree to comply with all applicable laws and regulations, including Hyperliquid's terms of service.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and fixes.</p>"},{"location":"troubleshooting/#missing-environment-variables","title":"Missing environment variables","text":"<p>Error: <code>HYPERLIQUID_PRIVATE_KEY must be set in .env file.</code> Error: <code>CROWDCENT_API_KEY not found in environment variables</code></p> <p>When <code>cc-liquid</code> is installed as a CLI tool, it may not automatically load variables from the <code>.env</code> file. You must load them into your shell session manually.</p> <p>Fix: Run this command from your project root in each new terminal session before using <code>cc-liquid</code>:</p> <pre><code>export $(grep -v '^#' .env | xargs)\n</code></pre> <p>This command reads your <code>.env</code> file, filters out comments, and exports the key-value pairs.</p> <ul> <li>Ensure <code>.env</code> exists with <code>HYPERLIQUID_PRIVATE_KEY</code> (or a profile-specific <code>signer_env</code> key).</li> <li>Add <code>CROWDCENT_API_KEY</code> for CrowdCent data, or switch to <code>local</code>/<code>numerai</code>.</li> </ul>"},{"location":"troubleshooting/#no-tradeable-assets","title":"No tradeable assets","text":"<p>Warning: <code>No predictions match Hyperliquid tradeable assets!</code></p> <ul> <li>Ensure prediction <code>asset_id_column</code> matches Hyperliquid coins (e.g., BTC, ETH)</li> <li>Use the correct <code>data.source</code> smart defaults or set columns explicitly</li> </ul>"},{"location":"troubleshooting/#trades-skipped-below-minimum","title":"Trades skipped (below minimum)","text":"<ul> <li>Increase <code>account_value</code> or <code>portfolio.target_leverage</code></li> <li>Reduce <code>portfolio.num_long/num_short</code></li> <li>Lower <code>execution.min_trade_value</code> with caution</li> </ul>"},{"location":"troubleshooting/#high-slippage-or-failed-orders","title":"High slippage or failed orders","text":"<ul> <li>Increase <code>execution.slippage_tolerance</code></li> <li>Reduce position count or leverage</li> <li>Avoid illiquid symbols (see Configuration \u2192 Execution)</li> </ul>"},{"location":"walkthrough/","title":"User Guide","text":"<p>This walkthrough explains the core flow and safe first steps.</p>"},{"location":"walkthrough/#1-install-and-configure","title":"1) Install and configure","text":"<p>Follow the installation guide to install and create <code>.env</code> and <code>cc-liquid-config.yaml</code>.</p> <pre><code>uv tool install cc-liquid\ncc-liquit init\n</code></pre> <p>Tip: enable tab autocompletion for a smoother CLI experience</p> <pre><code>cc-liquid completion install\n</code></pre>"},{"location":"walkthrough/#2-confirm-profileconfigdata","title":"2) Confirm profile/config/data","text":"<p><pre><code>cc-liquid config\n</code></pre> See configuration for defaults and overrides: Configuration \u2192 Data</p> <p>Set your data source in <code>cc-liquid-config.yaml</code> or via <code>--set data.source=[crowdcent|numerai]</code>:</p> <ul> <li><code>crowdcent</code>: latest consolidated metamodel from CrowdCent</li> <li><code>numerai</code>: Numerai Crypto metamodel</li> <li><code>local</code>: your own parquet/csv file</li> </ul>"},{"location":"walkthrough/#3-inspect-account-and-positions","title":"3) Inspect account and positions","text":"<pre><code>cc-liquid account\n</code></pre> <p>This shows your current portfolio state:</p> <p></p> <p>Warning</p> <p>Errors on this step are most often due to incrorrectly configured/loaded private keys. You may need to ensure your .env is loaded by running:</p> <p><pre><code>export UV_ENV_FILE=.env\n</code></pre> OR</p> <pre><code>export $(grep -v '^#' .env | xargs)\n</code></pre> <p>This command reads your <code>.env</code> file, filters out comments, and exports the variables. You'll need to run it in each new terminal session.</p>"},{"location":"walkthrough/#4-backtest-before-going-live","title":"4) Backtest before going live","text":"<p>Backtesting Limitations</p> <p>Remember that backtesting has inherent limitations. Past performance does not guarantee future results. Results are hypothetical and may not account for all real-world factors. Historical data and simulations may contain inaccuracies. Always validate with paper trading before using real capital.</p> <p>Data Required</p> <p>You need to provide your own historical data files for backtesting: - <code>raw_data.parquet</code> - Historical price data - <code>predictions.parquet</code> - Your prediction signals</p> <p>See the Backtesting documentation for detailed format requirements.</p> <p>Before trading with real funds, test your strategy on historical data:</p> <pre><code># Ensure you have prepared the required data files first\ncc-liquid analyze\n</code></pre> <p></p> <p>Find optimal parameters:</p> <pre><code># Grid search optimization\ncc-liquid optimize\n</code></pre> <p></p> <p>The optimizer tests combinations of:</p> <ul> <li>Position counts (long/short)</li> <li>Leverage levels</li> <li>Rebalance frequencies</li> </ul>"},{"location":"walkthrough/#5-plan-and-execute-rebalancing","title":"5) Plan and execute rebalancing","text":"<pre><code>cc-liquid rebalance\n</code></pre> <p>The CLI will display a detailed plan showing:</p> <ul> <li>Current vs target positions</li> <li>Required trades to rebalance</li> <li>Portfolio metrics and leverage</li> </ul> <p></p> <p>After reviewing the plan, you'll be prompted to confirm execution. To skip the confirmation prompt:</p> <pre><code>cc-liquid rebalance --skip-confirm\n</code></pre> <p>You can adjust parameters on the fly:</p> <pre><code>cc-liquid rebalance --set portfolio.num_long=12 --set portfolio.num_short=8 --set portfolio.target_leverage=2.0\n</code></pre>"},{"location":"walkthrough/#how-rebalancing-works","title":"How rebalancing works","text":"<ol> <li> <p>Load predictions</p> <ul> <li>Downloads latest metamodel from CrowdCent/Numerai (or loads local file)</li> <li>Keeps most recent prediction per asset</li> </ul> </li> <li> <p>Select assets</p> <ul> <li>Top <code>num_long</code> assets for long positions (highest predictions)</li> <li>Bottom <code>num_short</code> assets for short positions (lowest predictions)</li> <li>Filters to only assets tradeable on Hyperliquid</li> </ul> </li> <li> <p>Size positions</p> <ul> <li>Equal-weight: <code>(account_value \u00d7 target_leverage) / total_positions</code></li> <li>Warns if position sizes fall below <code>min_trade_value</code></li> </ul> </li> <li> <p>Generate trades</p> <ul> <li>Calculates delta between current and target positions</li> <li>Rounds sizes to exchange precision (<code>sz_decimals</code>)</li> <li>Marks trades below minimum as \"skipped\"</li> </ul> </li> <li> <p>Execute orders</p> <ul> <li>Market orders: uses <code>slippage_tolerance</code> for aggressive pricing (away from mid)</li> <li>Limit orders: uses <code>limit_price_offset</code> for passive pricing (at or inside mid)</li> <li>Reports fills, failures, and actual slippage</li> </ul> </li> </ol> <p>After execution completes:</p> <p></p>"},{"location":"walkthrough/#flatten-close-all-positions","title":"Flatten (close all positions)","text":"<pre><code>cc-liquid close-all\n</code></pre> <p>In the event you want to return your entire portfolio/vault to cash, <code>close-all</code> plans and executes trades to close all trades to 0 notional value. Add <code>--skip-confirm</code> to skip confirmation messages.</p>"},{"location":"walkthrough/#5-continuous-mode-autopilot","title":"5) Continuous mode (autopilot)","text":"<p>Schedules execution at <code>portfolio.rebalancing.at_time</code> every <code>every_n_days</code>. See Autopilot &amp; Scheduling for details.</p> <pre><code>cc-liquid run --skip-confirm   # executes automatically on schedule\n</code></pre> <p>Dashboard/monitor view:</p> <p></p>"},{"location":"walkthrough/#safety-notes","title":"Safety notes","text":"<ul> <li>Leverage increases liquidation risk; start with 1.0x</li> <li>Ensure <code>execution.min_trade_value</code> and slippage are appropriate</li> <li>Use Hyperliquid testnet first (<code>--set is_testnet=true</code>)</li> </ul>"},{"location":"api/cli/","title":"CLI Reference","text":"<p>This page provides auto-generated documentation for the <code>cc-liquid</code> CLI tool.</p>"},{"location":"api/cli/#cc-liquid","title":"cc-liquid","text":"<p>cc-liquid - A metamodel-based rebalancer for Hyperliquid.</p> <p>Usage:</p> <pre><code>cc-liquid [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-account","title":"cc-liquid account","text":"<p>Show comprehensive account and positions summary.</p> <p>Usage:</p> <pre><code>cc-liquid account [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-analyze","title":"cc-liquid analyze","text":"<p>Run backtest analysis on historical data.</p> <p>\u26a0\ufe0f IMPORTANT DISCLAIMER: Past performance does not guarantee future results. Backtesting results are hypothetical and have inherent limitations. Actual trading results may differ significantly. Always consider market conditions, liquidity, and execution costs that may not be fully captured in simulations.</p> <p>Usage:</p> <pre><code>cc-liquid analyze [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --prices TEXT                   Path to price data (parquet file with date,\n                                  id, close columns)\n  --start-date [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  Start date for backtest (YYYY-MM-DD)\n  --end-date [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  End date for backtest (YYYY-MM-DD)\n  --set TEXT                      Override config values (e.g., --set\n                                  portfolio.num_long=15 --set\n                                  data.source=numerai)\n  --fee-bps FLOAT                 Trading fee in basis points\n  --slippage-bps FLOAT            Slippage cost in basis points\n  --prediction-lag INTEGER        Days between prediction date and trading\n                                  date (default: 1, use higher values to avoid\n                                  look-ahead bias)\n  --save-daily TEXT               Save daily results to CSV file\n  --show-positions                Show detailed position analysis table\n  --verbose                       Show detailed progress\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-apply-stops","title":"cc-liquid apply-stops","text":"<p>Manually apply stop losses to all open positions.</p> <p>Useful after: - Limit orders fill (were resting on book during rebalance) - Manual trades outside the bot - Bot restart with existing positions - Changing stop loss configuration</p> <p>Usage:</p> <pre><code>cc-liquid apply-stops [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --set TEXT  Override config values (e.g., --set\n              portfolio.stop_loss.sides=both)\n  --help      Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-cancel-orders","title":"cc-liquid cancel-orders","text":"<p>Cancel open orders.</p> <p>Usage:</p> <pre><code>cc-liquid cancel-orders [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --coin TEXT     Cancel orders for specific coin only\n  --skip-confirm  Skip confirmation prompt\n  --help          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-close-all","title":"cc-liquid close-all","text":"<p>Close all positions and return to cash.</p> <p>Usage:</p> <pre><code>cc-liquid close-all [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm  Skip confirmation prompt for closing positions.\n  --set TEXT      Override config values (e.g., --set is_testnet=true)\n  --force         Force close positions below min notional by composing a two-\n                  step workaround.\n  --help          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-completion","title":"cc-liquid completion","text":"<p>Shell completion utilities.</p> <p>Usage:</p> <pre><code>cc-liquid completion [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-completion-install","title":"cc-liquid completion install","text":"<p>Install shell completion for the current user.</p> <p>Writes the generated completion script to a standard location and, for Bash/Zsh, appends a source line to the user's rc file idempotently.</p> <p>Usage:</p> <pre><code>cc-liquid completion install [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --shell [bash|zsh|fish]  Target shell. Defaults to auto-detect from $SHELL.\n  --prog-name TEXT         Program name to install completion for (as\n                           installed on PATH).  [default: cc-liquid]\n  --help                   Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-config","title":"cc-liquid config","text":"<p>Show the current configuration.</p> <p>Usage:</p> <pre><code>cc-liquid config [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-download-crowdcent","title":"cc-liquid download-crowdcent","text":"<p>Download the CrowdCent meta model.</p> <p>Usage:</p> <pre><code>cc-liquid download-crowdcent [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -o, --output TEXT  Output file path (defaults to path in config).\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-download-numerai","title":"cc-liquid download-numerai","text":"<p>Download the Numerai meta model.</p> <p>Usage:</p> <pre><code>cc-liquid download-numerai [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -o, --output TEXT  Output file path (defaults to path in config).\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-history","title":"cc-liquid history","text":"<p>Show trade fill history or PNL summary.</p> <p>Usage:</p> <pre><code>cc-liquid history [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --days INTEGER   Show fills from last N days\n  --start TEXT     Start date (YYYY-MM-DD)\n  --end TEXT       End date (YYYY-MM-DD)\n  --limit INTEGER  Max number of fills to show\n  --pnl            Show PNL summary by currency instead of fill history\n  --coin TEXT      Filter fills by specific coin (e.g., BTC, ETH)\n  --help           Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-init","title":"cc-liquid init","text":"<p>Interactive setup wizard for first-time users.</p> <p>Guides you through creating config files with validation and helpful defaults.</p> <p>Usage:</p> <pre><code>cc-liquid init [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --non-interactive  Skip interactive setup, use defaults\n  --help             Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-optimize","title":"cc-liquid optimize","text":"<p>Optimize backtest parameters using parallel grid search.</p> <p>\u26a0\ufe0f IMPORTANT DISCLAIMER: Optimization results are based on historical data and are subject to overfitting. Parameters that performed well in the past may not perform well in the future. Always use out-of-sample testing and forward walk analysis. Consider that optimized parameters may be curve-fit to historical noise rather than true patterns.</p> <p>Usage:</p> <pre><code>cc-liquid optimize [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --prices TEXT                   Path to price data\n  --start-date [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  Start date for backtest (YYYY-MM-DD)\n  --end-date [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n                                  End date for backtest (YYYY-MM-DD)\n  --set TEXT                      Override config values (e.g., --set\n                                  data.source=numerai)\n  --num-longs TEXT                Comma-separated list of long positions to\n                                  test\n  --num-shorts TEXT               Comma-separated list of short positions to\n                                  test\n  --leverages TEXT                Comma-separated list of leverage values to\n                                  test\n  --rebalance-days TEXT           Comma-separated list of rebalance\n                                  frequencies to test\n  --rank-powers TEXT              Comma-separated list of rank power values to\n                                  test (0=equal weight)\n  --metric [sharpe|cagr|calmar]   Optimization metric\n  --max-drawdown FLOAT            Maximum drawdown constraint (e.g., 0.2 for\n                                  20%)\n  --fee-bps FLOAT                 Trading fee in basis points\n  --slippage-bps FLOAT            Slippage cost in basis points\n  --prediction-lag INTEGER        Days between prediction date and trading\n                                  date (default: 1, use higher values to avoid\n                                  look-ahead bias)\n  --top-n INTEGER                 Show top N results\n  --apply-best                    Run full analysis with best parameters\n  --save-results TEXT             Save optimization results to CSV\n  --plot                          Show contour plots of results\n  --max-workers INTEGER           Number of parallel workers (default: auto)\n  --clear-cache                   Clear cached optimization results\n  --verbose                       Show detailed progress\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-orders","title":"cc-liquid orders","text":"<p>Show current open orders.</p> <p>Usage:</p> <pre><code>cc-liquid orders [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile","title":"cc-liquid profile","text":"<p>Manage configuration profiles (owner/vault/signer).</p> <p>Usage:</p> <pre><code>cc-liquid profile [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-list","title":"cc-liquid profile list","text":"<p>List available profiles from YAML and highlight the active one.</p> <p>Usage:</p> <pre><code>cc-liquid profile list [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-show","title":"cc-liquid profile show","text":"<p>Show details for a profile (defaults to active).</p> <p>Usage:</p> <pre><code>cc-liquid profile show [OPTIONS] [NAME]\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-profile-use","title":"cc-liquid profile use","text":"<p>Set active profile and persist to YAML.</p> <p>Usage:</p> <pre><code>cc-liquid profile use [OPTIONS] NAME\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-rebalance","title":"cc-liquid rebalance","text":"<p>Execute rebalancing based on the configured data source.</p> <p>Usage:</p> <pre><code>cc-liquid rebalance [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm        Skip confirmation prompt for executing trades.\n  --set TEXT            Override config values (e.g., --set\n                        data.source=numerai --set portfolio.num_long=10)\n  --cancel-open-orders  Cancel all open orders before rebalancing (useful with\n                        Gtc orders).\n  --help                Show this message and exit.\n</code></pre>"},{"location":"api/cli/#cc-liquid-run","title":"cc-liquid run","text":"<p>Start continuous monitoring and automatic rebalancing with live dashboard.</p> <p>Usage:</p> <pre><code>cc-liquid run [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --skip-confirm   Skip confirmation prompt for executing trades.\n  --set TEXT       Override config values (e.g., --set is_testnet=true)\n  --refresh FLOAT  Dashboard update cadence in seconds.  [default: 1.0]\n  --tmux           Run inside a fixed tmux session (attach if exists, else\n                   create and run).\n  --help           Show this message and exit.\n</code></pre>"},{"location":"api/python/","title":"Python API reference","text":"<p>This package is primarily a CLI. The core modules are documented below for advanced users.</p>"},{"location":"api/python/#config","title":"Config","text":""},{"location":"api/python/#cc_liquid.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Manages configuration for the trading bot, loading from a YAML file and environment variables.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Manages configuration for the trading bot, loading from a YAML file\n    and environment variables.\n    \"\"\"\n\n    # Private Keys and API Credentials (from .env)\n    CROWDCENT_API_KEY: str | None = None\n    HYPERLIQUID_PRIVATE_KEY: str | None = (\n        None  # Private key for signing (owner or approved agent wallet)\n    )\n\n    # Environment\n    is_testnet: bool = False\n    base_url: str = \"https://api.hyperliquid.xyz\"\n\n    # Profiles (addresses in config; secrets remain in env)\n    active_profile: str | None = \"default\"\n    profiles: dict[str, Any] = field(default_factory=dict)\n\n    # Resolved addresses from active profile (owner/vault)\n    HYPERLIQUID_ADDRESS: str | None = None\n    HYPERLIQUID_VAULT_ADDRESS: str | None = None\n\n    # Nested Configs\n    data: DataSourceConfig = field(default_factory=DataSourceConfig)\n    portfolio: PortfolioConfig = field(default_factory=PortfolioConfig)\n    execution: ExecutionConfig = field(default_factory=ExecutionConfig)\n\n    def __post_init__(self):\n        \"\"\"Load environment variables and YAML config after initialization.\"\"\"\n        self._load_env_vars()\n        self._load_yaml_config()\n        self._resolve_profile()  # Must come AFTER loading YAML (which loads profiles)\n        self._set_base_url()\n        self._validate()\n\n    def _load_env_vars(self):\n        \"\"\"Load secrets-only from .env; addresses come from YAML/profiles.\"\"\"\n        load_dotenv()\n        self.CROWDCENT_API_KEY = os.getenv(\"CROWDCENT_API_KEY\")\n        # Don't load private key here - will be resolved based on profile's signer_env\n\n    def _load_yaml_config(self, config_path: str | None = None):\n        \"\"\"Loads and overrides config from a YAML file.\"\"\"\n        path = config_path or DEFAULT_CONFIG_PATH\n        if os.path.exists(path):\n            with open(path) as f:\n                yaml_config: dict[str, Any] = yaml.safe_load(f) or {}\n\n            for key, value in yaml_config.items():\n                if hasattr(self, key):\n                    # Handle nested dataclasses\n                    if isinstance(value, dict) and is_dataclass(getattr(self, key)):\n                        nested_config_obj = getattr(self, key)\n                        for nested_key, nested_value in value.items():\n                            if hasattr(nested_config_obj, nested_key):\n                                # Handle double nested dataclasses\n                                if isinstance(nested_value, dict) and is_dataclass(\n                                    getattr(nested_config_obj, nested_key)\n                                ):\n                                    nested_dataclass = getattr(\n                                        nested_config_obj, nested_key\n                                    )\n                                    for deep_key, deep_value in nested_value.items():\n                                        if hasattr(nested_dataclass, deep_key):\n                                            setattr(\n                                                nested_dataclass, deep_key, deep_value\n                                            )\n                                else:\n                                    setattr(nested_config_obj, nested_key, nested_value)\n                    else:\n                        # Direct assignment for non-dataclass fields (like profiles dict)\n                        setattr(self, key, value)\n\n    def _set_base_url(self):\n        \"\"\"Sets the base URL based on the is_testnet flag.\"\"\"\n        if self.is_testnet:\n            self.base_url = \"https://api.hyperliquid-testnet.xyz\"\n\n    def _resolve_profile(self):\n        \"\"\"Resolve owner/vault addresses and signer key from the active profile.\"\"\"\n        # If no profiles defined, skip resolution\n        if not self.profiles:\n            return\n\n        active = self.active_profile or \"default\"\n        profile = self.profiles.get(active, {})\n\n        # Extract owner and vault from profile\n        owner = profile.get(\"owner\")\n        vault = profile.get(\"vault\")\n\n        # Set addresses (owner is required, vault is optional)\n        self.HYPERLIQUID_ADDRESS = owner\n        self.HYPERLIQUID_VAULT_ADDRESS = vault\n\n        # Resolve signer key from environment based on profile's signer_env\n        signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        self.HYPERLIQUID_PRIVATE_KEY = os.getenv(signer_env)\n\n        # Fallback to default env var if custom signer_env not found\n        if not self.HYPERLIQUID_PRIVATE_KEY and signer_env != \"HYPERLIQUID_PRIVATE_KEY\":\n            self.HYPERLIQUID_PRIVATE_KEY = os.getenv(\"HYPERLIQUID_PRIVATE_KEY\")\n\n    def refresh_runtime(self):\n        \"\"\"Refresh runtime configuration after changes (e.g., CLI overrides).\"\"\"\n        self._set_base_url()\n        self._resolve_profile()\n        self._validate()\n\n    def _validate(self):\n        \"\"\"Validate that required configuration is present.\n\n        Note: This is lenient during initial module load to allow CLI commands\n        like 'profile list' to work even without complete setup.\n        \"\"\"\n        # Check if active profile exists\n        if self.profiles and self.active_profile:\n            if self.active_profile not in self.profiles:\n                available = \", \".join(sorted(self.profiles.keys()))\n                raise ValueError(\n                    f\"Active profile '{self.active_profile}' not found. Available profiles: {available}\"\n                )\n\n        # Don't validate addresses/keys during module import - let individual commands handle it\n        # This allows 'profile list', 'config', etc to work without full setup\n\n    def validate_for_trading(self):\n        \"\"\"Strict validation for trading operations.\n\n        Call this before any trading operations to ensure all required config is present.\n        \"\"\"\n        # Validate we have required addresses from profile\n        if not self.HYPERLIQUID_ADDRESS and not self.HYPERLIQUID_VAULT_ADDRESS:\n            raise ValueError(\n                \"Profile must specify 'owner' or 'vault' address in cc-liquid-config.yaml\"\n            )\n\n        # Validate we have a private key\n        if not self.HYPERLIQUID_PRIVATE_KEY:\n            # Better error message showing which env var is expected\n            signer_env = \"HYPERLIQUID_PRIVATE_KEY\"\n            if self.profiles and self.active_profile:\n                profile = self.profiles.get(self.active_profile, {})\n                signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n            raise ValueError(\n                f\"Private key not found. Set '{signer_env}' in your .env file.\"\n            )\n\n        # Validate order type\n        if self.execution.order_type not in (\"market\", \"limit\"):\n            raise ValueError(\n                f\"Invalid order_type: {self.execution.order_type}. Must be 'market' or 'limit'\"\n            )\n\n        # Validate time in force\n        if self.execution.time_in_force not in (\"Ioc\", \"Gtc\", \"Alo\"):\n            raise ValueError(\n                f\"Invalid time_in_force: {self.execution.time_in_force}. Must be 'Ioc', 'Gtc', or 'Alo'\"\n            )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dictionary representation of the config.\"\"\"\n        portfolio_dict = self.portfolio.__dict__.copy()\n        # Convert nested dataclasses to dict\n        if hasattr(self.portfolio, \"rebalancing\"):\n            portfolio_dict[\"rebalancing\"] = self.portfolio.rebalancing.__dict__\n        if hasattr(self.portfolio, \"stop_loss\"):\n            portfolio_dict[\"stop_loss\"] = self.portfolio.stop_loss.__dict__\n\n        # Profile summary (non-secret)\n        active_profile = self.active_profile\n        prof = self.profiles.get(active_profile) if self.profiles else {}\n        signer_env_name = (\n            prof.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n            if prof\n            else \"HYPERLIQUID_PRIVATE_KEY\"\n        )\n        profile_dict = {\n            \"active\": active_profile,\n            \"owner\": self.HYPERLIQUID_ADDRESS,\n            \"vault\": self.HYPERLIQUID_VAULT_ADDRESS,\n            \"signer_env\": signer_env_name,\n        }\n\n        return {\n            \"is_testnet\": self.is_testnet,\n            \"profile\": profile_dict,\n            \"data\": self.data.__dict__,\n            \"portfolio\": portfolio_dict,\n            \"execution\": self.execution.__dict__,\n        }\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Load environment variables and YAML config after initialization.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Load environment variables and YAML config after initialization.\"\"\"\n    self._load_env_vars()\n    self._load_yaml_config()\n    self._resolve_profile()  # Must come AFTER loading YAML (which loads profiles)\n    self._set_base_url()\n    self._validate()\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.refresh_runtime","title":"<code>refresh_runtime()</code>","text":"<p>Refresh runtime configuration after changes (e.g., CLI overrides).</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def refresh_runtime(self):\n    \"\"\"Refresh runtime configuration after changes (e.g., CLI overrides).\"\"\"\n    self._set_base_url()\n    self._resolve_profile()\n    self._validate()\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dictionary representation of the config.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dictionary representation of the config.\"\"\"\n    portfolio_dict = self.portfolio.__dict__.copy()\n    # Convert nested dataclasses to dict\n    if hasattr(self.portfolio, \"rebalancing\"):\n        portfolio_dict[\"rebalancing\"] = self.portfolio.rebalancing.__dict__\n    if hasattr(self.portfolio, \"stop_loss\"):\n        portfolio_dict[\"stop_loss\"] = self.portfolio.stop_loss.__dict__\n\n    # Profile summary (non-secret)\n    active_profile = self.active_profile\n    prof = self.profiles.get(active_profile) if self.profiles else {}\n    signer_env_name = (\n        prof.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        if prof\n        else \"HYPERLIQUID_PRIVATE_KEY\"\n    )\n    profile_dict = {\n        \"active\": active_profile,\n        \"owner\": self.HYPERLIQUID_ADDRESS,\n        \"vault\": self.HYPERLIQUID_VAULT_ADDRESS,\n        \"signer_env\": signer_env_name,\n    }\n\n    return {\n        \"is_testnet\": self.is_testnet,\n        \"profile\": profile_dict,\n        \"data\": self.data.__dict__,\n        \"portfolio\": portfolio_dict,\n        \"execution\": self.execution.__dict__,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.config.Config.validate_for_trading","title":"<code>validate_for_trading()</code>","text":"<p>Strict validation for trading operations.</p> <p>Call this before any trading operations to ensure all required config is present.</p> Source code in <code>src/cc_liquid/config.py</code> <pre><code>def validate_for_trading(self):\n    \"\"\"Strict validation for trading operations.\n\n    Call this before any trading operations to ensure all required config is present.\n    \"\"\"\n    # Validate we have required addresses from profile\n    if not self.HYPERLIQUID_ADDRESS and not self.HYPERLIQUID_VAULT_ADDRESS:\n        raise ValueError(\n            \"Profile must specify 'owner' or 'vault' address in cc-liquid-config.yaml\"\n        )\n\n    # Validate we have a private key\n    if not self.HYPERLIQUID_PRIVATE_KEY:\n        # Better error message showing which env var is expected\n        signer_env = \"HYPERLIQUID_PRIVATE_KEY\"\n        if self.profiles and self.active_profile:\n            profile = self.profiles.get(self.active_profile, {})\n            signer_env = profile.get(\"signer_env\", \"HYPERLIQUID_PRIVATE_KEY\")\n        raise ValueError(\n            f\"Private key not found. Set '{signer_env}' in your .env file.\"\n        )\n\n    # Validate order type\n    if self.execution.order_type not in (\"market\", \"limit\"):\n        raise ValueError(\n            f\"Invalid order_type: {self.execution.order_type}. Must be 'market' or 'limit'\"\n        )\n\n    # Validate time in force\n    if self.execution.time_in_force not in (\"Ioc\", \"Gtc\", \"Alo\"):\n        raise ValueError(\n            f\"Invalid time_in_force: {self.execution.time_in_force}. Must be 'Ioc', 'Gtc', or 'Alo'\"\n        )\n</code></pre>"},{"location":"api/python/#data-loading","title":"Data loading","text":""},{"location":"api/python/#cc_liquid.data_loader.DataLoader","title":"<code>DataLoader</code>","text":"<p>Factory for creating data sources.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>class DataLoader:\n    \"\"\"Factory for creating data sources.\"\"\"\n\n    @staticmethod\n    def from_file(path: str, date_col: str, id_col: str, pred_col: str) -&gt; pl.DataFrame:\n        \"\"\"Create a file data source and load data.\"\"\"\n        return FileDataSource(\n            path,\n            date_column=date_col,\n            asset_id_column=id_col,\n            prediction_column=pred_col,\n        ).load()\n\n    @staticmethod\n    def from_dataframe(\n        df: pl.DataFrame, date_col: str, id_col: str, pred_col: str\n    ) -&gt; pl.DataFrame:\n        \"\"\"Create a DataFrame data source and load data.\"\"\"\n        return DataFrameDataSource(\n            df,\n            date_column=date_col,\n            asset_id_column=id_col,\n            prediction_column=pred_col,\n        ).load()\n\n    @staticmethod\n    def from_crowdcent_api(\n        api_key: str | None = None,\n        challenge_slug: str = \"hyperliquid-ranking\",\n        download_path: str | None = None,\n        date_col: str = \"release_date\",\n        id_col: str = \"id\",\n        pred_col: str = \"pred_10d\",\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Download and load the CrowdCent meta model.\n\n        Args:\n            api_key: CrowdCent API key (if None, will try to load from env)\n            challenge_slug: The challenge to download data for\n            download_path: Optional path to save the downloaded file\n            date_col: Date column name in the meta model\n            id_col: Asset ID column name in the meta model\n            pred_col: Prediction column name to use from the meta model\n\n        Returns:\n            Polars DataFrame with original column names\n        \"\"\"\n        from crowdcent_challenge import ChallengeClient\n\n        if api_key is None:\n            import os\n\n            api_key = os.getenv(\"CROWDCENT_API_KEY\")\n            if not api_key:\n                raise ValueError(\"CROWDCENT_API_KEY not found in environment variables\")\n\n        client = ChallengeClient(challenge_slug=challenge_slug, api_key=api_key)\n\n        if download_path is None:\n            download_path = \"predictions.parquet\"\n\n        client.download_meta_model(download_path)\n\n        return DataLoader.from_file(\n            path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n        )\n\n    @staticmethod\n    def from_numerai_api(\n        download_path: str | None = None,\n        date_col: str = \"date\",\n        id_col: str = \"symbol\",\n        pred_col: str = \"meta_model\",\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Download and load the Numerai crypto meta model.\n\n        Args:\n            download_path: Optional path to save the downloaded file\n            date_col: Date column name in the meta model\n            id_col: Asset ID/symbol column name in the meta model\n            pred_col: Prediction column name to use from the meta model\n\n        Returns:\n            Polars DataFrame with original column names\n        \"\"\"\n        try:\n            from numerapi import CryptoAPI\n        except ImportError:\n            raise ImportError(\n                \"numerapi is required. Install with: uv add cc-liquid[numerai]\"\n            )\n\n        api = CryptoAPI()\n\n        if download_path is None:\n            download_path = \"predictions.parquet\"\n\n        api.download_dataset(\"v1.0/historical_meta_models.parquet\", download_path)\n\n        return DataLoader.from_file(\n            path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n        )\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_crowdcent_api","title":"<code>from_crowdcent_api(api_key=None, challenge_slug='hyperliquid-ranking', download_path=None, date_col='release_date', id_col='id', pred_col='pred_10d')</code>  <code>staticmethod</code>","text":"<p>Download and load the CrowdCent meta model.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str | None</code> <p>CrowdCent API key (if None, will try to load from env)</p> <code>None</code> <code>challenge_slug</code> <code>str</code> <p>The challenge to download data for</p> <code>'hyperliquid-ranking'</code> <code>download_path</code> <code>str | None</code> <p>Optional path to save the downloaded file</p> <code>None</code> <code>date_col</code> <code>str</code> <p>Date column name in the meta model</p> <code>'release_date'</code> <code>id_col</code> <code>str</code> <p>Asset ID column name in the meta model</p> <code>'id'</code> <code>pred_col</code> <code>str</code> <p>Prediction column name to use from the meta model</p> <code>'pred_10d'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Polars DataFrame with original column names</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_crowdcent_api(\n    api_key: str | None = None,\n    challenge_slug: str = \"hyperliquid-ranking\",\n    download_path: str | None = None,\n    date_col: str = \"release_date\",\n    id_col: str = \"id\",\n    pred_col: str = \"pred_10d\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Download and load the CrowdCent meta model.\n\n    Args:\n        api_key: CrowdCent API key (if None, will try to load from env)\n        challenge_slug: The challenge to download data for\n        download_path: Optional path to save the downloaded file\n        date_col: Date column name in the meta model\n        id_col: Asset ID column name in the meta model\n        pred_col: Prediction column name to use from the meta model\n\n    Returns:\n        Polars DataFrame with original column names\n    \"\"\"\n    from crowdcent_challenge import ChallengeClient\n\n    if api_key is None:\n        import os\n\n        api_key = os.getenv(\"CROWDCENT_API_KEY\")\n        if not api_key:\n            raise ValueError(\"CROWDCENT_API_KEY not found in environment variables\")\n\n    client = ChallengeClient(challenge_slug=challenge_slug, api_key=api_key)\n\n    if download_path is None:\n        download_path = \"predictions.parquet\"\n\n    client.download_meta_model(download_path)\n\n    return DataLoader.from_file(\n        path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n    )\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_dataframe","title":"<code>from_dataframe(df, date_col, id_col, pred_col)</code>  <code>staticmethod</code>","text":"<p>Create a DataFrame data source and load data.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_dataframe(\n    df: pl.DataFrame, date_col: str, id_col: str, pred_col: str\n) -&gt; pl.DataFrame:\n    \"\"\"Create a DataFrame data source and load data.\"\"\"\n    return DataFrameDataSource(\n        df,\n        date_column=date_col,\n        asset_id_column=id_col,\n        prediction_column=pred_col,\n    ).load()\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_file","title":"<code>from_file(path, date_col, id_col, pred_col)</code>  <code>staticmethod</code>","text":"<p>Create a file data source and load data.</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_file(path: str, date_col: str, id_col: str, pred_col: str) -&gt; pl.DataFrame:\n    \"\"\"Create a file data source and load data.\"\"\"\n    return FileDataSource(\n        path,\n        date_column=date_col,\n        asset_id_column=id_col,\n        prediction_column=pred_col,\n    ).load()\n</code></pre>"},{"location":"api/python/#cc_liquid.data_loader.DataLoader.from_numerai_api","title":"<code>from_numerai_api(download_path=None, date_col='date', id_col='symbol', pred_col='meta_model')</code>  <code>staticmethod</code>","text":"<p>Download and load the Numerai crypto meta model.</p> <p>Parameters:</p> Name Type Description Default <code>download_path</code> <code>str | None</code> <p>Optional path to save the downloaded file</p> <code>None</code> <code>date_col</code> <code>str</code> <p>Date column name in the meta model</p> <code>'date'</code> <code>id_col</code> <code>str</code> <p>Asset ID/symbol column name in the meta model</p> <code>'symbol'</code> <code>pred_col</code> <code>str</code> <p>Prediction column name to use from the meta model</p> <code>'meta_model'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Polars DataFrame with original column names</p> Source code in <code>src/cc_liquid/data_loader.py</code> <pre><code>@staticmethod\ndef from_numerai_api(\n    download_path: str | None = None,\n    date_col: str = \"date\",\n    id_col: str = \"symbol\",\n    pred_col: str = \"meta_model\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Download and load the Numerai crypto meta model.\n\n    Args:\n        download_path: Optional path to save the downloaded file\n        date_col: Date column name in the meta model\n        id_col: Asset ID/symbol column name in the meta model\n        pred_col: Prediction column name to use from the meta model\n\n    Returns:\n        Polars DataFrame with original column names\n    \"\"\"\n    try:\n        from numerapi import CryptoAPI\n    except ImportError:\n        raise ImportError(\n            \"numerapi is required. Install with: uv add cc-liquid[numerai]\"\n        )\n\n    api = CryptoAPI()\n\n    if download_path is None:\n        download_path = \"predictions.parquet\"\n\n    api.download_dataset(\"v1.0/historical_meta_models.parquet\", download_path)\n\n    return DataLoader.from_file(\n        path=download_path, date_col=date_col, id_col=id_col, pred_col=pred_col\n    )\n</code></pre>"},{"location":"api/python/#trading-logic","title":"Trading logic","text":""},{"location":"api/python/#cc_liquid.trader.CCLiquid","title":"<code>CCLiquid</code>","text":"<p>Handles all interactions with the Hyperliquid exchange.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>class CCLiquid:\n    \"\"\"\n    Handles all interactions with the Hyperliquid exchange.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: Config,\n        callbacks: CCLiquidCallbacks | None = None,\n        skip_ws: bool = True,\n    ):\n        self.config = config\n        self.callbacks = callbacks or NoOpCallbacks()\n\n        # Validate config for trading operations\n        self.config.validate_for_trading()\n\n        self.account: LocalAccount = self._get_account()\n        self.exchange = Exchange(\n            self.account,\n            self.config.base_url,\n            vault_address=(self.config.HYPERLIQUID_VAULT_ADDRESS or None),\n            account_address=self.config.HYPERLIQUID_ADDRESS,\n        )\n        self.info = Info(self.config.base_url, skip_ws=skip_ws)\n        self.logger = logging.getLogger(__name__)\n        # Lazy-loaded map of coin -&gt; szDecimals from Info.meta()[\"universe\"].\n        # Perps only: Hyperliquid perps use max 6 decimals for price rules.\n        self._coin_to_sz_decimals: dict[str, int] | None = None\n\n    def _get_account(self) -&gt; LocalAccount:\n        \"\"\"Creates an eth_account LocalAccount object from the private key.\"\"\"\n        from eth_account import Account\n\n        return Account.from_key(self.config.HYPERLIQUID_PRIVATE_KEY)\n\n    def get_user_state(self) -&gt; dict[str, Any]:\n        \"\"\"Retrieves the current state of the user's account.\"\"\"\n        # Always query Info using the portfolio owner: vault (if set) or master address.\n        # Never use the agent/signer address for Info, as it has no balances.\n        owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n        if not owner:\n            raise ValueError(\n                \"Missing portfolio owner. Set HYPERLIQUID_VAULT_ADDRESS or HYPERLIQUID_ADDRESS.\"\n            )\n        return self.info.user_state(owner)\n\n    def get_positions(self) -&gt; dict[str, Any]:\n        \"\"\"Retrieves the user's open positions as a dict.\"\"\"\n        user_state = self.get_user_state()\n        positions = {}\n        for position_data in user_state.get(\"assetPositions\", []):\n            position = position_data.get(\"position\", {})\n            if float(position.get(\"szi\", 0)) != 0:\n                positions[position[\"coin\"]] = position\n        return positions\n\n    def get_account_value(self) -&gt; float:\n        \"\"\"Retrieves the total account value in USD.\"\"\"\n        user_state = self.get_user_state()\n        return float(user_state[\"marginSummary\"][\"accountValue\"])\n\n    def get_portfolio_info(self) -&gt; PortfolioInfo:\n        \"\"\"Get complete portfolio information as structured data.\"\"\"\n        try:\n            user_state = self.get_user_state()\n        except Exception as e:\n            self.logger.warning(f\"Could not get user state: {e}\")\n            # Return empty portfolio if we can't connect\n            return PortfolioInfo(\n                account=AccountInfo(\n                    account_value=0,\n                    total_position_value=0,\n                    margin_used=0,\n                    free_collateral=0,\n                    cash_balance=0,\n                    withdrawable=0,\n                    current_leverage=0,\n                ),\n                positions=[],\n            )\n\n        margin_summary = user_state.get(\"marginSummary\", {}) if user_state else {}\n        all_mids = self.info.all_mids() if user_state else {}\n\n        # Build account info\n        account_info = AccountInfo(\n            account_value=float(margin_summary.get(\"accountValue\", 0)),\n            total_position_value=float(margin_summary.get(\"totalNtlPos\", 0)),\n            margin_used=float(margin_summary.get(\"totalMarginUsed\", 0)),\n            free_collateral=float(margin_summary.get(\"accountValue\", 0))\n            - float(margin_summary.get(\"totalMarginUsed\", 0)),\n            cash_balance=float(margin_summary.get(\"totalRawUsd\", 0)),\n            withdrawable=float(user_state.get(\"withdrawable\", 0)),\n            current_leverage=float(margin_summary.get(\"totalNtlPos\", 0))\n            / float(margin_summary.get(\"accountValue\", 1))\n            if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n            else 0,\n            raw_margin_summary=margin_summary,\n        )\n\n        # Add cross margin info if available\n        cross_margin = user_state.get(\"crossMarginSummary\")\n        if cross_margin:\n            account_info.cross_leverage = (\n                float(cross_margin.get(\"accountValue\", 0))\n                / float(margin_summary.get(\"accountValue\", 1))\n                if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n                else 0\n            )\n            account_info.cross_margin_used = float(\n                cross_margin.get(\"totalMarginUsed\", 0)\n            )\n            account_info.cross_maintenance_margin = float(\n                cross_margin.get(\"totalMaintenanceMargin\", 0)\n            )\n            account_info.raw_cross_margin_summary = cross_margin\n\n        # Build positions list\n        positions = []\n        for position_data in user_state.get(\"assetPositions\", []):\n            pos = position_data.get(\"position\", {})\n            size = float(pos.get(\"szi\", 0))\n\n            if size == 0:\n                continue\n\n            coin = pos[\"coin\"]\n            entry_px = float(pos.get(\"entryPx\", 0))\n            mark_px = float(all_mids.get(coin, entry_px))\n            position_value = abs(size * mark_px)\n\n            # Calculate unrealized PnL\n            if size &gt; 0:\n                unrealized_pnl = (mark_px - entry_px) * size\n                side = \"LONG\"\n            else:\n                unrealized_pnl = (entry_px - mark_px) * abs(size)\n                side = \"SHORT\"\n\n            return_pct = (\n                (unrealized_pnl / (abs(size) * entry_px) * 100) if entry_px &gt; 0 else 0\n            )\n\n            positions.append(\n                Position(\n                    coin=coin,\n                    side=side,\n                    size=abs(size),\n                    entry_price=entry_px,\n                    mark_price=mark_px,\n                    value=position_value,\n                    unrealized_pnl=unrealized_pnl,\n                    return_pct=return_pct,\n                    liquidation_price=float(pos[\"liquidationPx\"])\n                    if \"liquidationPx\" in pos and pos[\"liquidationPx\"] is not None\n                    else None,\n                    margin_used=float(pos[\"marginUsed\"])\n                    if \"marginUsed\" in pos and pos[\"marginUsed\"] is not None\n                    else None,\n                )\n            )\n\n        return PortfolioInfo(account=account_info, positions=positions)\n\n    # --- Rounding helpers (Perps only) ---\n    def _load_sz_decimals_map(self, force_refresh: bool = False) -&gt; dict[str, int]:\n        \"\"\"Load and cache coin -&gt; szDecimals from exchange meta.\n\n        Per Hyperliquid rounding guidance for orders, sizes must be rounded to a\n        coin-specific number of decimals (szDecimals). We cache from `info.meta()`\n        and refresh on demand.\n        \"\"\"\n        if self._coin_to_sz_decimals is None or force_refresh:\n            try:\n                universe = self.info.meta().get(\"universe\", [])\n                self._coin_to_sz_decimals = {\n                    asset.get(\"name\"): int(asset.get(\"szDecimals\", 2))\n                    for asset in universe\n                    if asset.get(\"name\") and not asset.get(\"isDelisted\", False)\n                }\n            except Exception as e:\n                self.logger.warning(f\"Failed to load szDecimals map: {e}\")\n                self._coin_to_sz_decimals = {}\n        return self._coin_to_sz_decimals\n\n    def _get_sz_decimals(self, coin: str) -&gt; int | None:\n        \"\"\"Return szDecimals for the given coin, refreshing meta once if needed.\"\"\"\n        sz_map = self._load_sz_decimals_map()\n        if coin not in sz_map:\n            sz_map = self._load_sz_decimals_map(force_refresh=True)\n        return sz_map.get(coin)\n\n    def _round_size(self, coin: str, size: float) -&gt; tuple[float, int] | None:\n        \"\"\"Round size per coin's szDecimals.\n\n        Returns (rounded_size, sz_decimals) or None if szDecimals are unknown.\n        \"\"\"\n        sz_decimals = self._get_sz_decimals(coin)\n        if sz_decimals is None:\n            return None\n        return round(size, sz_decimals), sz_decimals\n\n    def _round_price_perp(self, coin: str, px: float) -&gt; float:\n        \"\"\"Round price according to Hyperliquid perp rules (used for limit orders).\n\n        Rules (per Hyperliquid):\n        - If px &gt; 100_000: round to integer.\n        - Else: round to 5 significant figures and at most (6 - szDecimals) decimals.\n        Reference: Hyperliquid SDK example rounding: see rounding.py\n        \"\"\"\n        if px &gt; 100_000:\n            return round(px)\n        sz_decimals = self._get_sz_decimals(coin)\n        # If unknown, still limit to 5 significant figures as a safe default.\n        if sz_decimals is None:\n            return float(f\"{px:.5g}\")\n        max_decimals = 6  # perps\n        return round(float(f\"{px:.5g}\"), max_decimals - sz_decimals)\n\n    def plan_rebalance(self, predictions: pl.DataFrame | None = None) -&gt; dict:\n        \"\"\"Compute a rebalancing plan without executing orders.\"\"\"\n        # Check for open orders (warning if present)\n        open_orders = self.get_open_orders()\n        if open_orders:\n            self.callbacks.warn(\n                f\"Found {len(open_orders)} open order(s). These may conflict with rebalancing.\"\n            )\n        # Load predictions if not provided\n        if predictions is None:\n            self.callbacks.info(\"Loading predictions...\")\n            predictions = self._load_predictions()\n\n            if predictions is None or predictions.is_empty():\n                self.callbacks.error(\"No predictions available, cannot rebalance\")\n                return {\n                    \"target_positions\": {},\n                    \"trades\": [],\n                    \"skipped_trades\": [],\n                    \"account_value\": 0.0,\n                    \"leverage\": self.config.portfolio.target_leverage,\n                    \"open_orders\": open_orders,\n                }\n\n            # Display prediction info\n            unique_assets = predictions[self.config.data.asset_id_column].n_unique()\n            latest_data = predictions[self.config.data.date_column].max()\n            self.callbacks.info(\n                f\"Loaded predictions for {unique_assets} assets (latest: {latest_data})\"\n            )\n\n        # Asset Selection, Position Calculation, and Trade Generation\n        target_positions = self._get_target_positions(predictions)\n        current_positions = self.get_positions()\n        trades, skipped_trades = self._calculate_trades(\n            target_positions, current_positions\n        )\n\n        # Build plan (including skipped trades)\n        account_value = self.get_account_value()\n        leverage = self.config.portfolio.target_leverage\n        return {\n            \"target_positions\": target_positions,\n            \"trades\": trades,\n            \"skipped_trades\": skipped_trades,\n            \"account_value\": account_value,\n            \"leverage\": leverage,\n            \"open_orders\": open_orders,\n        }\n\n    def execute_plan(self, plan: dict) -&gt; dict:\n        \"\"\"Execute a precomputed plan, returning structured results.\"\"\"\n        trades: list[dict] = plan.get(\"trades\", [])\n        if not trades:\n            # Nothing to do\n            return {\"successful_trades\": [], \"all_trades\": trades}\n\n        # Prioritize leverage reduction: execute closes/reductions (and flips) before opens\n        trades = self._sort_trades_for_leverage_reduction(trades)\n\n        self.callbacks.info(f\"Starting execution of {len(trades)} trades...\")\n        successful_trades = self._execute_trades(trades)\n\n        # Apply stop losses after execution\n        sl_result = None\n        if self.config.portfolio.stop_loss.sides != \"none\":\n            self.callbacks.info(\"Applying stop losses to positions...\")\n            sl_result = self.apply_stop_losses()\n\n            # Report SL results\n            if sl_result.get(\"status\") == \"ok\":\n                applied_count = sl_result.get(\"total_applied\", 0)\n                if applied_count &gt; 0:\n                    self.callbacks.info(f\"\u2713 Placed {applied_count} stop loss order(s)\")\n\n                # Warn about resting orders\n                resting = [t for t in successful_trades if t.get(\"resting\")]\n                if resting:\n                    self.callbacks.warn(\n                        f\"{len(resting)} order(s) resting on book. \"\n                        \"Run 'cc-liquid apply-stops' after they fill to add protection.\"\n                    )\n\n        return {\n            \"successful_trades\": successful_trades,\n            \"all_trades\": trades,\n            \"stop_loss_result\": sl_result\n        }\n\n    def plan_close_all_positions(self, *, force: bool = False) -&gt; dict:\n        \"\"\"Plan to close all open positions (return to cash) without executing orders.\"\"\"\n        current_positions = self.get_positions()\n\n        if not current_positions:\n            self.callbacks.info(\"No open positions to close.\")\n            return {\n                \"target_positions\": {},\n                \"trades\": [],\n                \"skipped_trades\": [],\n                \"account_value\": self.get_account_value(),\n                \"leverage\": self.config.portfolio.target_leverage,\n            }\n\n        self.callbacks.info(\"Closing all positions to return to cash...\")\n\n        # Create target positions of 0 for all current positions\n        target_positions = {coin: 0 for coin in current_positions.keys()}\n        trades, skipped_trades = self._calculate_trades(\n            target_positions, current_positions, force=force\n        )\n\n        account_value = self.get_account_value()\n        leverage = self.config.portfolio.target_leverage\n        return {\n            \"target_positions\": target_positions,\n            \"trades\": trades,\n            \"skipped_trades\": skipped_trades,\n            \"account_value\": account_value,\n            \"leverage\": leverage,\n        }\n\n    def _get_target_positions(self, predictions: pl.DataFrame) -&gt; dict[str, float]:\n        \"\"\"Calculate target notionals using configurable weighting scheme.\"\"\"\n\n        latest_predictions = self._get_latest_predictions(predictions)\n        tradeable_predictions = self._filter_tradeable_predictions(latest_predictions)\n\n        if tradeable_predictions.height == 0:\n            return {}\n\n        id_col = self.config.data.asset_id_column\n        pred_col = self.config.data.prediction_column\n\n        sorted_preds = tradeable_predictions.sort(pred_col, descending=True)\n\n        num_long = self.config.portfolio.num_long\n        num_short = self.config.portfolio.num_short\n\n        if sorted_preds.height &lt; num_long + num_short:\n            self.callbacks.warn(\n                f\"Limited tradeable assets: {sorted_preds.height} available; \"\n                f\"requested {num_long} longs and {num_short} shorts\"\n            )\n\n        long_assets = sorted_preds.head(num_long)[id_col].to_list()\n        short_assets = (\n            sorted_preds.sort(pred_col, descending=False)\n            .head(num_short)[id_col]\n            .to_list()\n            if num_short &gt; 0\n            else []\n        )\n\n        account_value = self.get_account_value()\n        target_leverage = self.config.portfolio.target_leverage\n        total_positions = len(long_assets) + len(short_assets)\n\n        if total_positions == 0 or account_value &lt;= 0 or target_leverage &lt;= 0:\n            return {}\n\n        self.callbacks.info(\n            f\"Target gross leverage: {target_leverage:.2f}x across {total_positions} positions\"\n        )\n\n        weights = weights_from_ranks(\n            latest_preds=tradeable_predictions.select([id_col, pred_col]),\n            id_col=id_col,\n            pred_col=pred_col,\n            long_assets=long_assets,\n            short_assets=short_assets,\n            target_gross=target_leverage,\n            power=self.config.portfolio.rank_power,\n        )\n\n        target_positions = {\n            asset: weight * account_value for asset, weight in weights.items()\n        }\n\n        # Warn if resulting notionals fall below exchange minimums\n        min_notional = self.config.execution.min_trade_value\n        undersized = [\n            asset\n            for asset, weight in target_positions.items()\n            if abs(weight) &lt; min_notional\n        ]\n        if undersized:\n            self.callbacks.warn(\n                \"Some target positions fall below minimum notional: \"\n                + \", \".join(sorted(undersized))\n            )\n\n        return target_positions\n\n    def _get_latest_predictions(self, predictions: pl.DataFrame) -&gt; pl.DataFrame:\n        \"\"\"Filters for the latest predictions for each asset by date.\"\"\"\n        return (\n            predictions.sort(self.config.data.date_column, descending=True)\n            .group_by(self.config.data.asset_id_column)\n            .first()\n        )\n\n    def _filter_tradeable_predictions(self, predictions: pl.DataFrame) -&gt; pl.DataFrame:\n        \"\"\"Filter predictions to Hyperliquid-listed assets.\"\"\"\n\n        universe = self.info.meta()[\"universe\"]\n        available_assets = {\n            p[\"name\"] for p in universe if not p.get(\"isDelisted\", False)\n        }\n\n        tradeable = predictions.filter(\n            pl.col(self.config.data.asset_id_column).is_in(available_assets)\n        )\n\n        if tradeable.height == 0:\n            self.logger.warning(\"No predictions match Hyperliquid tradeable assets!\")\n            self.callbacks.error(\n                \"Error: No predictions match Hyperliquid tradeable assets!\"\n            )\n            self.callbacks.info(\n                f\"Available on Hyperliquid: {sorted(list(available_assets)[:10])}{'...' if len(available_assets) &gt; 10 else ''}\"\n            )\n            prediction_assets = (\n                predictions[self.config.data.asset_id_column].unique().to_list()\n            )\n            self.callbacks.info(\n                f\"In predictions: {sorted(prediction_assets[:10])}{'...' if len(prediction_assets) &gt; 10 else ''}\"\n            )\n\n        return tradeable\n\n    def _calculate_trades(\n        self,\n        target_positions: dict[str, float],\n        current_positions: dict[str, Any],\n        *,\n        force: bool = False,\n    ) -&gt; tuple[list[dict[str, Any]], list[dict[str, Any]]]:\n        \"\"\"Calculates the trades required to reach the target portfolio using market orders.\n\n        Returns:\n            (executable_trades, skipped_trades) - trades that can be executed and those below minimum\n        \"\"\"\n        trades = []\n        skipped_trades = []  # Track trades we can't execute\n        all_mids = self.info.all_mids()\n\n\n        fee_info = self.get_fee_summary()\n        taker_rate = float(fee_info.get(\"userCrossRate\", 0.00035))\n\n        all_assets = set(target_positions.keys()) | set(current_positions.keys())\n\n        for asset in all_assets:\n            target_value = target_positions.get(asset, 0)\n\n            # Get current position details\n            current_position = current_positions.get(asset, {})\n            current_size = float(current_position.get(\"szi\", 0))\n\n            # Ensure we have a mid price; otherwise skip\n            if asset not in all_mids:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": \"No mid price available\",\n                    }\n                )\n                continue\n\n            price = float(all_mids[asset])\n\n            # Calculate current value with proper sign\n            # szi is positive for long, negative for short\n            current_value = current_size * price\n\n            # Calculate the value delta we need to achieve\n            delta_value = target_value - current_value\n\n            # Determine trade direction\n            # If delta_value &gt; 0, we need to buy (increase position or reduce short)\n            # If delta_value &lt; 0, we need to sell (decrease position or increase short)\n            is_buy = delta_value &gt; 0\n            size = abs(delta_value) / price\n\n            # Round the size using szDecimals from meta (perps only)\n            coin = asset\n            rounded = self._round_size(coin, size)\n            if rounded is None:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": \"Unknown szDecimals (meta)\",\n                    }\n                )\n                continue\n            size, sz_decimals = rounded\n\n            # If rounding collapses to zero, skip\n            if size == 0:\n                skipped_trades.append(\n                    {\n                        \"coin\": asset,\n                        \"target_value\": target_value,\n                        \"skipped\": True,\n                        \"skip_reason\": f\"Rounded size is 0 at {sz_decimals} dp\",\n                    }\n                )\n                continue\n\n            # Check if trade is below minimum value threshold\n            min_trade_value = self.config.execution.min_trade_value\n            # Classify the trade type for clearer downstream handling\n            # Types: open, close, reduce, increase, flip\n            trade_type: str\n            if current_value == 0:\n                trade_type = \"open\" if target_value != 0 else \"increase\"\n            elif target_value == 0:\n                trade_type = \"close\"\n            else:\n                same_sign = (current_value &gt; 0 and target_value &gt; 0) or (\n                    current_value &lt; 0 and target_value &lt; 0\n                )\n                if same_sign:\n                    trade_type = (\n                        \"reduce\"\n                        if abs(target_value) &lt; abs(current_value)\n                        else \"increase\"\n                    )\n                else:\n                    trade_type = \"flip\"\n\n            trade_data = {\n                \"coin\": asset,\n                \"is_buy\": is_buy,\n                \"sz\": size,\n                \"price\": price,\n                \"current_value\": current_value,\n                \"target_value\": target_value,\n                \"delta_value\": delta_value,\n                \"type\": trade_type,\n                \"estimated_fee\": abs(delta_value) * taker_rate,\n            }\n\n            # Re-evaluate min notional AFTER rounding size\n            if abs(size * price) &lt; min_trade_value:\n                # Below minimum. If not forcing or not a pure close-to-zero scenario, skip.\n                if not force or target_value != 0:\n                    trade_data[\"skipped\"] = True\n                    trade_data[\"skip_reason\"] = f\"Below minimum ${min_trade_value}\"\n                    skipped_trades.append(trade_data)\n                else:\n                    forced, reason = self._compose_force_close_trades(\n                        asset, price, current_value, min_trade_value, taker_rate\n                    )\n                    if forced is None:\n                        skipped_trades.append(\n                            {\n                                \"coin\": asset,\n                                \"target_value\": target_value,\n                                \"skipped\": True,\n                                \"skip_reason\": reason\n                                or \"Force close composition failed\",\n                            }\n                        )\n                    else:\n                        trades.extend(forced)\n            else:\n                # Add to executable trades\n                trades.append(trade_data)\n\n        return trades, skipped_trades\n\n    def _sort_trades_for_leverage_reduction(\n        self, trades: list[dict[str, Any]]\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Return trades ordered to reduce leverage first using explicit trade types.\n\n        Priority: close (0), reduce/flip (1), increase (2), open (3). Stable ordering within groups.\n        \"\"\"\n        priority = {\"close\": 0, \"reduce\": 1, \"flip\": 1, \"increase\": 2, \"open\": 3}\n\n        def sort_key(t: dict[str, Any]):\n            # Forced close chains must execute in sequence: increase (0) then close (1)\n            if t.get(\"force\"):\n                return (0, t.get(\"force_id\", \"\"), t.get(\"force_seq\", 0))\n            return (1, priority.get(t.get(\"type\", \"increase\"), 2), 0)\n\n        return sorted(trades, key=sort_key)\n\n    def _compose_force_close_trades(\n        self, coin: str, price: float, current_value: float, min_trade_value: float, taker_rate: float\n    ) -&gt; tuple[list[dict[str, Any]] | None, str | None]:\n        \"\"\"Compose the two-step forced close for sub-minimum closes.\n        i.e. if we have a position of less than $10, we want to close it to $0, we need to increase the position\n        to at least $10, then close it to $0.\n\n        Returns (trades, None) on success or (None, reason) on failure.\n        \"\"\"\n        rounded_up = self._round_size_up_to_min_notional(coin, min_trade_value, price)\n        if rounded_up is None:\n            return None, \"Unknown szDecimals (meta)\"\n        min_increase_sz, _ = rounded_up\n\n        increase_is_buy = current_value &gt; 0\n        force_id = f\"force_close:{coin}\"\n\n        step1_delta = min_increase_sz * price if increase_is_buy else -(min_increase_sz * price)\n\n        step1 = {\n            \"coin\": coin,\n            \"is_buy\": increase_is_buy,\n            \"sz\": min_increase_sz,\n            \"price\": price,\n            \"current_value\": current_value,\n            \"target_value\": current_value\n            + (\n                min_increase_sz * price\n                if current_value &gt;= 0\n                else -min_increase_sz * price\n            ),\n            \"delta_value\": step1_delta,\n            \"type\": \"increase\",\n            \"force\": True,\n            \"force_id\": force_id,\n            \"force_seq\": 0,\n            \"estimated_fee\": abs(step1_delta) * taker_rate,\n        }\n\n        total_notional_to_close = abs(current_value) + (min_increase_sz * price)\n        close_is_buy = not increase_is_buy\n        close_sz_rounded = self._round_size(coin, total_notional_to_close / price)\n        if close_sz_rounded is None:\n            return None, \"Unknown szDecimals (meta)\"\n        close_sz, _ = close_sz_rounded\n\n        step2_delta = total_notional_to_close if close_is_buy else -total_notional_to_close\n\n        step2 = {\n            \"coin\": coin,\n            \"is_buy\": close_is_buy,\n            \"sz\": close_sz,\n            \"price\": price,\n            \"current_value\": current_value\n            + (\n                min_increase_sz * price\n                if increase_is_buy\n                else -(min_increase_sz * price)\n            ),\n            \"target_value\": 0,\n            \"delta_value\": step2_delta,\n            \"type\": \"close\",\n            \"force\": True,\n            \"force_id\": force_id,\n            \"force_seq\": 1,\n            \"estimated_fee\": abs(step2_delta) * taker_rate,\n        }\n\n        # Ensure both meet minimum notional\n        if (step1[\"sz\"] * price) &lt; min_trade_value or (\n            step2[\"sz\"] * price\n        ) &lt; min_trade_value:\n            return (\n                None,\n                f\"Below minimum even after force composition (${min_trade_value})\",\n            )\n\n        return [step1, step2], None\n\n    def _round_size_up_to_min_notional(\n        self, coin: str, target_notional: float, price: float\n    ) -&gt; tuple[float, int] | None:\n        \"\"\"Return (size, decimals) such that size*price &gt;= target_notional after rounding to szDecimals.\n\n        Rounds up to the nearest step defined by szDecimals to satisfy the notional constraint.\n        \"\"\"\n        sz_decimals = self._get_sz_decimals(coin)\n        if sz_decimals is None:\n            return None\n        raw_size = target_notional / price if price &gt; 0 else 0\n        if raw_size &lt;= 0:\n            return (0.0, sz_decimals)\n        step = 10 ** (-sz_decimals)\n        # Avoid floating imprecision by working in integer steps\n        steps_needed = math.ceil(raw_size / step)\n        rounded_up_size = steps_needed * step\n        # Round to the allowed decimals to avoid long floats\n        rounded_up_size = round(rounded_up_size, sz_decimals)\n        return rounded_up_size, sz_decimals\n\n    def _execute_trades(self, trades: list[dict[str, Any]]) -&gt; list[dict[str, Any]]:\n        \"\"\"Executes a list of trades sequentially with configurable order type and time-in-force.\"\"\"\n        if not trades:\n            return []\n\n        successful_trades = []\n        failed_trades = []\n\n        # Show progress during execution\n        self.callbacks.info(f\"Executing {len(trades)} trades...\")\n\n        for i, trade in enumerate(trades, 1):\n            # Notify callback of trade start\n            self.callbacks.on_trade_start(i, len(trades), trade)\n\n            try:\n                self.logger.debug(f\"Executing trade: {trade}\")\n\n                coin = trade[\"coin\"]\n                is_buy = trade[\"is_buy\"]\n                size = trade[\"sz\"]\n\n                # Determine limit price based on order_type\n                if self.config.execution.order_type == \"limit\":\n                    # Use passive pricing: buy below mid, sell above mid\n                    mid_price = float(self.info.all_mids()[coin])\n                    offset = self.config.execution.limit_price_offset\n\n                    if is_buy:\n                        limit_px = self._round_price_perp(coin, mid_price * (1 - offset))\n                    else:\n                        limit_px = self._round_price_perp(coin, mid_price * (1 + offset))\n                else:  # market\n                    # Use slippage price (aggressive) for market orders\n                    limit_px = self.exchange._slippage_price(\n                        coin, is_buy, self.config.execution.slippage_tolerance\n                    )\n\n                # Build single order request\n                order_request = {\n                    \"coin\": coin,\n                    \"is_buy\": is_buy,\n                    \"sz\": size,\n                    \"limit_px\": limit_px,\n                    \"order_type\": {\"limit\": {\"tif\": self.config.execution.time_in_force}},\n                    \"reduce_only\": False,\n                }\n\n                # Execute single order via bulk_orders with single-item list\n                result = self.exchange.bulk_orders([order_request])\n\n                # Handle error responses\n                if result.get(\"status\") == \"err\":\n                    error_msg = result.get(\"response\", \"Unknown error\")\n                    self.callbacks.on_trade_fail(trade, error_msg)\n                    failed_trades.append(trade)\n                    continue\n\n                # Handle success responses\n                response = result.get(\"response\", {})\n                if not isinstance(response, dict):\n                    self.callbacks.on_trade_fail(trade, f\"Unexpected response format: {response}\")\n                    failed_trades.append(trade)\n                    continue\n\n                statuses = response.get(\"data\", {}).get(\"statuses\", [])\n\n                if not statuses:\n                    self.callbacks.on_trade_fail(trade, \"No status returned\")\n                    failed_trades.append(trade)\n                    continue\n\n                status = statuses[0]  # Get first (and only) status\n\n                # Check for filled orders\n                if \"filled\" in status:\n                    filled_data = status[\"filled\"]\n                    avg_px = float(filled_data.get(\"avgPx\", trade[\"price\"]))\n\n                    # Calculate slippage\n                    if trade[\"is_buy\"]:\n                        slippage_pct = (\n                            (avg_px - trade[\"price\"]) / trade[\"price\"]\n                        ) * 100\n                    else:\n                        slippage_pct = (\n                            (trade[\"price\"] - avg_px) / trade[\"price\"]\n                        ) * 100\n\n                    # Extract actual fee from API response\n                    actual_fee = float(filled_data.get(\"fee\", 0))\n\n                    self.callbacks.on_trade_fill(trade, filled_data, slippage_pct)\n\n                    successful_trades.append(\n                        {\n                            **trade,\n                            \"fill_data\": filled_data,\n                            \"slippage_pct\": slippage_pct,\n                            \"actual_fee\": actual_fee,\n                            \"status\": \"filled\",\n                        }\n                    )\n\n                # Check for resting orders (Gtc/Alo orders posted to book)\n                elif \"resting\" in status and self.config.execution.time_in_force in (\"Gtc\", \"Alo\"):\n                    resting_data = status[\"resting\"]\n                    oid = resting_data.get(\"oid\")\n\n                    # This is a success for Gtc/Alo - order is on the book\n                    self.callbacks.info(\n                        f\"  {trade['coin']}: Order posted to book (OID: {oid}). \"\n                        f\"Check with 'cc-liquid orders'\"\n                    )\n\n                    successful_trades.append(\n                        {\n                            **trade,\n                            \"resting\": True,\n                            \"oid\": oid,\n                            \"status\": \"resting\",\n                        }\n                    )\n\n                # Handle errors or actual failures\n                else:\n                    if \"error\" in status:\n                        error_msg = status[\"error\"]\n                    else:\n                        error_msg = \"Order rejected or not filled\"\n\n                    self.callbacks.on_trade_fail(trade, error_msg)\n                    failed_trades.append(trade)\n\n            except Exception as e:\n                self.callbacks.on_trade_fail(trade, str(e))\n                self.logger.error(f\"Error executing trade for {trade['coin']}: {e}\")\n                failed_trades.append(trade)\n\n        # Notify callback of batch completion\n        self.callbacks.on_batch_complete(successful_trades, failed_trades)\n\n        return successful_trades\n\n    def load_state(self) -&gt; datetime | None:\n        \"\"\"Public wrapper to load last rebalance timestamp.\"\"\"\n        return self._load_state()\n\n    def save_state(self, last_rebalance_date: datetime) -&gt; None:\n        \"\"\"Public wrapper to persist last rebalance timestamp.\"\"\"\n        self._save_state(last_rebalance_date)\n\n    def compute_next_rebalance_time(\n        self, last_rebalance_date: datetime | None, now: datetime | None = None\n    ) -&gt; datetime:\n        \"\"\"Compute the next scheduled rebalance timestamp in UTC.\n\n        Rules:\n        - If this is the first run (no last date): schedule for today at configured time; if\n          already past that time, return \"now\" to indicate it is due immediately.\n        - Otherwise: schedule exactly every_n_days after the last rebalance date, at the\n          configured time.\n        \"\"\"\n        cfg = self.config.portfolio.rebalancing\n        now_utc = now or datetime.now(timezone.utc)\n\n        hour, minute = map(int, cfg.at_time.split(\":\"))\n        rebalance_time = time(hour=hour, minute=minute)\n\n        if last_rebalance_date is None:\n            today_at = datetime.combine(\n                now_utc.date(), rebalance_time, tzinfo=timezone.utc\n            )\n            return today_at if now_utc &lt; today_at else now_utc\n\n        next_date = last_rebalance_date.date() + timedelta(days=cfg.every_n_days)\n        return datetime.combine(next_date, rebalance_time, tzinfo=timezone.utc)\n\n    def _load_state(self) -&gt; datetime | None:\n        \"\"\"Load the last rebalance date from persistent state.\"\"\"\n        import json\n        import os\n\n        state_file = \".cc_liquid_state.json\"\n        if not os.path.exists(state_file):\n            return None\n\n        try:\n            with open(state_file) as f:\n                state = json.load(f)\n                last_date = datetime.fromisoformat(state.get(\"last_rebalance_date\"))\n                return last_date\n        except Exception as e:\n            self.logger.warning(f\"Could not load state file: {e}\")\n            return None\n\n    def _save_state(self, last_rebalance_date: datetime):\n        \"\"\"Save the last rebalance date to persistent state.\"\"\"\n        import json\n\n        state_file = \".cc_liquid_state.json\"\n        with open(state_file, \"w\") as f:\n            json.dump({\"last_rebalance_date\": last_rebalance_date.isoformat()}, f)\n\n    def get_open_orders(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get current open orders.\n\n        Returns:\n            List of open orders with details like coin, size, limit price, side, etc.\n        \"\"\"\n        owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n        if not owner:\n            raise ValueError(\"Missing portfolio owner address\")\n        return self.info.open_orders(owner)\n\n    def cancel_open_orders(self, coin: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Cancel open orders, optionally filtered by coin.\n\n        Args:\n            coin: If provided, only cancel orders for this coin. If None, cancel all.\n\n        Returns:\n            Result of the cancel operation\n        \"\"\"\n        open_orders = self.get_open_orders()\n\n        if not open_orders:\n            return {\"status\": \"ok\", \"response\": \"No open orders to cancel\"}\n\n        # Filter by coin if specified\n        if coin:\n            orders_to_cancel = [o for o in open_orders if o[\"coin\"] == coin]\n        else:\n            orders_to_cancel = open_orders\n\n        if not orders_to_cancel:\n            return {\n                \"status\": \"ok\",\n                \"response\": f\"No open orders found for {coin}\" if coin else \"No orders to cancel\",\n            }\n\n        # Build cancel requests\n        cancel_requests = [\n            {\"coin\": order[\"coin\"], \"oid\": order[\"oid\"]} for order in orders_to_cancel\n        ]\n\n        # Execute bulk cancel\n        self.logger.info(f\"Cancelling {len(cancel_requests)} open orders...\")\n        result = self.exchange.bulk_cancel(cancel_requests)\n\n        return result\n\n    def get_fill_history(\n        self, start_time: int | None = None, end_time: int | None = None\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get fill history with optional time range.\n\n        Args:\n            start_time: Unix timestamp in milliseconds (optional)\n            end_time: Unix timestamp in milliseconds (optional)\n\n        Returns:\n            List of fills with execution details, prices, sizes, and fees\n        \"\"\"\n        owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n        if not owner:\n            raise ValueError(\"Missing portfolio owner address\")\n\n        if start_time is not None:\n            return self.info.user_fills_by_time(owner, start_time, end_time)\n        return self.info.user_fills(owner)\n\n    def get_fee_summary(self) -&gt; dict[str, Any]:\n        \"\"\"Get fee rates and trading volume statistics.\n\n        Returns:\n            Dictionary containing fee rates (maker/taker), volume stats, and fee schedule\n        \"\"\"\n        owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n        if not owner:\n            raise ValueError(\"Missing portfolio owner address\")\n        return self.info.user_fees(owner)\n\n    def _should_apply_stop_loss(self, side: str) -&gt; bool:\n        \"\"\"Check if stop loss should be applied to a position side.\"\"\"\n        sides_config = self.config.portfolio.stop_loss.sides\n        if sides_config == \"none\":\n            return False\n        if sides_config == \"both\":\n            return True\n        if sides_config == \"long_only\" and side == \"LONG\":\n            return True\n        if sides_config == \"short_only\" and side == \"SHORT\":\n            return True\n        return False\n\n    def cancel_all_tpsl_orders(self) -&gt; dict[str, Any]:\n        \"\"\"Cancel all existing TP/SL orders across the portfolio.\"\"\"\n        open_orders = self.get_open_orders()\n\n        if not open_orders:\n            return {\"status\": \"ok\", \"response\": \"No open orders\", \"cancelled\": 0}\n\n        # Filter for TP/SL orders - check both nested structure and direct\n        tpsl_orders = []\n        for o in open_orders:\n            order_type = o.get(\"orderType\", {})\n            # Check if it's a trigger order (TP/SL)\n            if isinstance(order_type, dict) and \"trigger\" in order_type:\n                tpsl_orders.append(o)\n            # Also check string format if API returns it differently\n            elif isinstance(order_type, str) and \"trigger\" in order_type.lower():\n                tpsl_orders.append(o)\n\n        if not tpsl_orders:\n            self.callbacks.info(f\"No existing TP/SL orders to cancel (found {len(open_orders)} other orders)\")\n            return {\"status\": \"ok\", \"response\": \"No TP/SL orders to cancel\", \"cancelled\": 0}\n\n        cancel_requests = [\n            {\"coin\": order[\"coin\"], \"oid\": order[\"oid\"]} \n            for order in tpsl_orders\n        ]\n\n        self.callbacks.info(f\"Cancelling {len(cancel_requests)} existing TP/SL order(s)...\")\n        result = self.exchange.bulk_cancel(cancel_requests)\n        result[\"cancelled\"] = len(cancel_requests)\n        return result\n\n    def apply_stop_losses(self) -&gt; dict[str, Any]:\n        \"\"\"Apply stop losses to all current open positions per config.\n\n        Returns:\n            Dict with counts of applied/skipped SLs and any errors\n        \"\"\"\n        if self.config.portfolio.stop_loss.sides == \"none\":\n            return {\n                \"status\": \"disabled\",\n                \"message\": \"Stop losses disabled in config (stop_loss.sides=none)\"\n            }\n\n        # Get current positions\n        positions = self.get_positions()\n        if not positions:\n            return {\n                \"status\": \"ok\",\n                \"applied\": 0,\n                \"message\": \"No open positions to protect\"\n            }\n\n        # Cancel existing TP/SL orders first\n        self.cancel_all_tpsl_orders()\n\n        # Get current prices\n        all_mids = self.info.all_mids()\n\n        applied = []\n        skipped = []\n        errors = []\n\n        # Count eligible positions first for progress tracking\n        eligible_positions = []\n        for coin, position in positions.items():\n            size = float(position.get(\"szi\", 0))\n            if size == 0:\n                continue\n            side = \"LONG\" if size &gt; 0 else \"SHORT\"\n            if self._should_apply_stop_loss(side):\n                eligible_positions.append(coin)\n\n        total_eligible = len(eligible_positions)\n\n        # Build all SL orders first\n        orders_to_place = []\n        order_metadata = []  # Track metadata for each order\n\n        for coin, position in positions.items():\n            size = float(position.get(\"szi\", 0))\n            if size == 0:\n                continue\n\n            side = \"LONG\" if size &gt; 0 else \"SHORT\"\n\n            # Check if this side should have SL\n            if not self._should_apply_stop_loss(side):\n                skipped.append({\"coin\": coin, \"reason\": f\"Side {side} not configured\"})\n                continue\n\n            # Get entry price\n            entry_px = float(position.get(\"entryPx\", 0))\n            if entry_px &lt;= 0:\n                skipped.append({\"coin\": coin, \"reason\": \"Invalid entry price\"})\n                continue\n\n            # Calculate trigger price\n            stop_pct = self.config.portfolio.stop_loss.pct\n            if side == \"LONG\":\n                trigger_px = entry_px * (1 - stop_pct)\n                is_buy = False  # SL on long = sell\n            else:  # SHORT\n                trigger_px = entry_px * (1 + stop_pct)\n                is_buy = True  # SL on short = buy\n\n            # Calculate limit price with slippage\n            slippage = self.config.portfolio.stop_loss.slippage\n            if is_buy:\n                limit_px = trigger_px * (1 + slippage)\n            else:\n                limit_px = trigger_px * (1 - slippage)\n\n            # Round prices\n            trigger_px = self._round_price_perp(coin, trigger_px)\n            limit_px = self._round_price_perp(coin, limit_px)\n\n            # Round size\n            rounded = self._round_size(coin, abs(size))\n            if rounded is None:\n                skipped.append({\"coin\": coin, \"reason\": \"Unknown szDecimals\"})\n                continue\n            sl_size, _ = rounded\n\n            # Build SL order\n            sl_order = {\n                \"coin\": coin,\n                \"is_buy\": is_buy,\n                \"sz\": sl_size,\n                \"limit_px\": limit_px,\n                \"order_type\": {\n                    \"trigger\": {\n                        \"isMarket\": False,  # Use limit for custom slippage\n                        \"triggerPx\": trigger_px,  # SDK handles string conversion\n                        \"tpsl\": \"sl\"\n                    }\n                },\n                \"reduce_only\": True,\n            }\n\n            orders_to_place.append(sl_order)\n            order_metadata.append({\n                \"coin\": coin,\n                \"side\": side,\n                \"entry_px\": entry_px,\n                \"trigger_px\": trigger_px,\n                \"limit_px\": limit_px,\n                \"size\": sl_size\n            })\n\n        # Place all orders in one batch\n        if orders_to_place:\n            self.callbacks.info(f\"Placing {len(orders_to_place)} stop loss order(s) in batch...\")\n\n            try:\n                result = self.exchange.bulk_orders(orders_to_place)\n\n                if result.get(\"status\") == \"ok\":\n                    # Process response statuses\n                    response = result.get(\"response\", {})\n                    statuses = response.get(\"data\", {}).get(\"statuses\", [])\n\n                    for i, status in enumerate(statuses):\n                        if i &gt;= len(order_metadata):\n                            break\n\n                        metadata = order_metadata[i]\n\n                        if \"resting\" in status:\n                            # SL order successfully placed\n                            applied.append(metadata)\n                        elif \"error\" in status:\n                            errors.append({\n                                \"coin\": metadata[\"coin\"],\n                                \"error\": status[\"error\"]\n                            })\n                        else:\n                            # Unexpected status\n                            errors.append({\n                                \"coin\": metadata[\"coin\"],\n                                \"error\": f\"Unexpected status: {status}\"\n                            })\n                else:\n                    # Bulk operation failed entirely\n                    for metadata in order_metadata:\n                        errors.append({\n                            \"coin\": metadata[\"coin\"],\n                            \"error\": result.get(\"response\", \"Bulk operation failed\")\n                        })\n            except Exception as e:\n                # Exception during bulk operation\n                for metadata in order_metadata:\n                    errors.append({\n                        \"coin\": metadata[\"coin\"],\n                        \"error\": str(e)\n                    })\n\n        return {\n            \"status\": \"ok\",\n            \"applied\": applied,\n            \"skipped\": skipped,\n            \"errors\": errors,\n            \"total_applied\": len(applied),\n            \"total_skipped\": len(skipped),\n            \"total_errors\": len(errors)\n        }\n\n    def _load_predictions(self) -&gt; pl.DataFrame | None:\n        \"\"\"Load predictions based on configured data source.\"\"\"\n        try:\n            if self.config.data.source == \"local\":\n                # Use local file\n                predictions = DataLoader.from_file(\n                    self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            elif self.config.data.source == \"crowdcent\":\n                # Download and use CrowdCent meta model\n                predictions = DataLoader.from_crowdcent_api(\n                    api_key=self.config.CROWDCENT_API_KEY,\n                    download_path=self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            elif self.config.data.source == \"numerai\":\n                # Download and use Numerai meta model\n                predictions = DataLoader.from_numerai_api(\n                    download_path=self.config.data.path,\n                    date_col=self.config.data.date_column,\n                    id_col=self.config.data.asset_id_column,\n                    pred_col=self.config.data.prediction_column,\n                )\n            else:\n                raise ValueError(f\"Unknown data source: {self.config.data.source}\")\n\n            return predictions\n\n        except Exception as e:\n            self.logger.error(f\"Error loading predictions: {e}\")\n            return None\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.apply_stop_losses","title":"<code>apply_stop_losses()</code>","text":"<p>Apply stop losses to all current open positions per config.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict with counts of applied/skipped SLs and any errors</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def apply_stop_losses(self) -&gt; dict[str, Any]:\n    \"\"\"Apply stop losses to all current open positions per config.\n\n    Returns:\n        Dict with counts of applied/skipped SLs and any errors\n    \"\"\"\n    if self.config.portfolio.stop_loss.sides == \"none\":\n        return {\n            \"status\": \"disabled\",\n            \"message\": \"Stop losses disabled in config (stop_loss.sides=none)\"\n        }\n\n    # Get current positions\n    positions = self.get_positions()\n    if not positions:\n        return {\n            \"status\": \"ok\",\n            \"applied\": 0,\n            \"message\": \"No open positions to protect\"\n        }\n\n    # Cancel existing TP/SL orders first\n    self.cancel_all_tpsl_orders()\n\n    # Get current prices\n    all_mids = self.info.all_mids()\n\n    applied = []\n    skipped = []\n    errors = []\n\n    # Count eligible positions first for progress tracking\n    eligible_positions = []\n    for coin, position in positions.items():\n        size = float(position.get(\"szi\", 0))\n        if size == 0:\n            continue\n        side = \"LONG\" if size &gt; 0 else \"SHORT\"\n        if self._should_apply_stop_loss(side):\n            eligible_positions.append(coin)\n\n    total_eligible = len(eligible_positions)\n\n    # Build all SL orders first\n    orders_to_place = []\n    order_metadata = []  # Track metadata for each order\n\n    for coin, position in positions.items():\n        size = float(position.get(\"szi\", 0))\n        if size == 0:\n            continue\n\n        side = \"LONG\" if size &gt; 0 else \"SHORT\"\n\n        # Check if this side should have SL\n        if not self._should_apply_stop_loss(side):\n            skipped.append({\"coin\": coin, \"reason\": f\"Side {side} not configured\"})\n            continue\n\n        # Get entry price\n        entry_px = float(position.get(\"entryPx\", 0))\n        if entry_px &lt;= 0:\n            skipped.append({\"coin\": coin, \"reason\": \"Invalid entry price\"})\n            continue\n\n        # Calculate trigger price\n        stop_pct = self.config.portfolio.stop_loss.pct\n        if side == \"LONG\":\n            trigger_px = entry_px * (1 - stop_pct)\n            is_buy = False  # SL on long = sell\n        else:  # SHORT\n            trigger_px = entry_px * (1 + stop_pct)\n            is_buy = True  # SL on short = buy\n\n        # Calculate limit price with slippage\n        slippage = self.config.portfolio.stop_loss.slippage\n        if is_buy:\n            limit_px = trigger_px * (1 + slippage)\n        else:\n            limit_px = trigger_px * (1 - slippage)\n\n        # Round prices\n        trigger_px = self._round_price_perp(coin, trigger_px)\n        limit_px = self._round_price_perp(coin, limit_px)\n\n        # Round size\n        rounded = self._round_size(coin, abs(size))\n        if rounded is None:\n            skipped.append({\"coin\": coin, \"reason\": \"Unknown szDecimals\"})\n            continue\n        sl_size, _ = rounded\n\n        # Build SL order\n        sl_order = {\n            \"coin\": coin,\n            \"is_buy\": is_buy,\n            \"sz\": sl_size,\n            \"limit_px\": limit_px,\n            \"order_type\": {\n                \"trigger\": {\n                    \"isMarket\": False,  # Use limit for custom slippage\n                    \"triggerPx\": trigger_px,  # SDK handles string conversion\n                    \"tpsl\": \"sl\"\n                }\n            },\n            \"reduce_only\": True,\n        }\n\n        orders_to_place.append(sl_order)\n        order_metadata.append({\n            \"coin\": coin,\n            \"side\": side,\n            \"entry_px\": entry_px,\n            \"trigger_px\": trigger_px,\n            \"limit_px\": limit_px,\n            \"size\": sl_size\n        })\n\n    # Place all orders in one batch\n    if orders_to_place:\n        self.callbacks.info(f\"Placing {len(orders_to_place)} stop loss order(s) in batch...\")\n\n        try:\n            result = self.exchange.bulk_orders(orders_to_place)\n\n            if result.get(\"status\") == \"ok\":\n                # Process response statuses\n                response = result.get(\"response\", {})\n                statuses = response.get(\"data\", {}).get(\"statuses\", [])\n\n                for i, status in enumerate(statuses):\n                    if i &gt;= len(order_metadata):\n                        break\n\n                    metadata = order_metadata[i]\n\n                    if \"resting\" in status:\n                        # SL order successfully placed\n                        applied.append(metadata)\n                    elif \"error\" in status:\n                        errors.append({\n                            \"coin\": metadata[\"coin\"],\n                            \"error\": status[\"error\"]\n                        })\n                    else:\n                        # Unexpected status\n                        errors.append({\n                            \"coin\": metadata[\"coin\"],\n                            \"error\": f\"Unexpected status: {status}\"\n                        })\n            else:\n                # Bulk operation failed entirely\n                for metadata in order_metadata:\n                    errors.append({\n                        \"coin\": metadata[\"coin\"],\n                        \"error\": result.get(\"response\", \"Bulk operation failed\")\n                    })\n        except Exception as e:\n            # Exception during bulk operation\n            for metadata in order_metadata:\n                errors.append({\n                    \"coin\": metadata[\"coin\"],\n                    \"error\": str(e)\n                })\n\n    return {\n        \"status\": \"ok\",\n        \"applied\": applied,\n        \"skipped\": skipped,\n        \"errors\": errors,\n        \"total_applied\": len(applied),\n        \"total_skipped\": len(skipped),\n        \"total_errors\": len(errors)\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.cancel_all_tpsl_orders","title":"<code>cancel_all_tpsl_orders()</code>","text":"<p>Cancel all existing TP/SL orders across the portfolio.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def cancel_all_tpsl_orders(self) -&gt; dict[str, Any]:\n    \"\"\"Cancel all existing TP/SL orders across the portfolio.\"\"\"\n    open_orders = self.get_open_orders()\n\n    if not open_orders:\n        return {\"status\": \"ok\", \"response\": \"No open orders\", \"cancelled\": 0}\n\n    # Filter for TP/SL orders - check both nested structure and direct\n    tpsl_orders = []\n    for o in open_orders:\n        order_type = o.get(\"orderType\", {})\n        # Check if it's a trigger order (TP/SL)\n        if isinstance(order_type, dict) and \"trigger\" in order_type:\n            tpsl_orders.append(o)\n        # Also check string format if API returns it differently\n        elif isinstance(order_type, str) and \"trigger\" in order_type.lower():\n            tpsl_orders.append(o)\n\n    if not tpsl_orders:\n        self.callbacks.info(f\"No existing TP/SL orders to cancel (found {len(open_orders)} other orders)\")\n        return {\"status\": \"ok\", \"response\": \"No TP/SL orders to cancel\", \"cancelled\": 0}\n\n    cancel_requests = [\n        {\"coin\": order[\"coin\"], \"oid\": order[\"oid\"]} \n        for order in tpsl_orders\n    ]\n\n    self.callbacks.info(f\"Cancelling {len(cancel_requests)} existing TP/SL order(s)...\")\n    result = self.exchange.bulk_cancel(cancel_requests)\n    result[\"cancelled\"] = len(cancel_requests)\n    return result\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.cancel_open_orders","title":"<code>cancel_open_orders(coin=None)</code>","text":"<p>Cancel open orders, optionally filtered by coin.</p> <p>Parameters:</p> Name Type Description Default <code>coin</code> <code>str | None</code> <p>If provided, only cancel orders for this coin. If None, cancel all.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Result of the cancel operation</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def cancel_open_orders(self, coin: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Cancel open orders, optionally filtered by coin.\n\n    Args:\n        coin: If provided, only cancel orders for this coin. If None, cancel all.\n\n    Returns:\n        Result of the cancel operation\n    \"\"\"\n    open_orders = self.get_open_orders()\n\n    if not open_orders:\n        return {\"status\": \"ok\", \"response\": \"No open orders to cancel\"}\n\n    # Filter by coin if specified\n    if coin:\n        orders_to_cancel = [o for o in open_orders if o[\"coin\"] == coin]\n    else:\n        orders_to_cancel = open_orders\n\n    if not orders_to_cancel:\n        return {\n            \"status\": \"ok\",\n            \"response\": f\"No open orders found for {coin}\" if coin else \"No orders to cancel\",\n        }\n\n    # Build cancel requests\n    cancel_requests = [\n        {\"coin\": order[\"coin\"], \"oid\": order[\"oid\"]} for order in orders_to_cancel\n    ]\n\n    # Execute bulk cancel\n    self.logger.info(f\"Cancelling {len(cancel_requests)} open orders...\")\n    result = self.exchange.bulk_cancel(cancel_requests)\n\n    return result\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.compute_next_rebalance_time","title":"<code>compute_next_rebalance_time(last_rebalance_date, now=None)</code>","text":"<p>Compute the next scheduled rebalance timestamp in UTC.</p> <p>Rules: - If this is the first run (no last date): schedule for today at configured time; if   already past that time, return \"now\" to indicate it is due immediately. - Otherwise: schedule exactly every_n_days after the last rebalance date, at the   configured time.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def compute_next_rebalance_time(\n    self, last_rebalance_date: datetime | None, now: datetime | None = None\n) -&gt; datetime:\n    \"\"\"Compute the next scheduled rebalance timestamp in UTC.\n\n    Rules:\n    - If this is the first run (no last date): schedule for today at configured time; if\n      already past that time, return \"now\" to indicate it is due immediately.\n    - Otherwise: schedule exactly every_n_days after the last rebalance date, at the\n      configured time.\n    \"\"\"\n    cfg = self.config.portfolio.rebalancing\n    now_utc = now or datetime.now(timezone.utc)\n\n    hour, minute = map(int, cfg.at_time.split(\":\"))\n    rebalance_time = time(hour=hour, minute=minute)\n\n    if last_rebalance_date is None:\n        today_at = datetime.combine(\n            now_utc.date(), rebalance_time, tzinfo=timezone.utc\n        )\n        return today_at if now_utc &lt; today_at else now_utc\n\n    next_date = last_rebalance_date.date() + timedelta(days=cfg.every_n_days)\n    return datetime.combine(next_date, rebalance_time, tzinfo=timezone.utc)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.execute_plan","title":"<code>execute_plan(plan)</code>","text":"<p>Execute a precomputed plan, returning structured results.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def execute_plan(self, plan: dict) -&gt; dict:\n    \"\"\"Execute a precomputed plan, returning structured results.\"\"\"\n    trades: list[dict] = plan.get(\"trades\", [])\n    if not trades:\n        # Nothing to do\n        return {\"successful_trades\": [], \"all_trades\": trades}\n\n    # Prioritize leverage reduction: execute closes/reductions (and flips) before opens\n    trades = self._sort_trades_for_leverage_reduction(trades)\n\n    self.callbacks.info(f\"Starting execution of {len(trades)} trades...\")\n    successful_trades = self._execute_trades(trades)\n\n    # Apply stop losses after execution\n    sl_result = None\n    if self.config.portfolio.stop_loss.sides != \"none\":\n        self.callbacks.info(\"Applying stop losses to positions...\")\n        sl_result = self.apply_stop_losses()\n\n        # Report SL results\n        if sl_result.get(\"status\") == \"ok\":\n            applied_count = sl_result.get(\"total_applied\", 0)\n            if applied_count &gt; 0:\n                self.callbacks.info(f\"\u2713 Placed {applied_count} stop loss order(s)\")\n\n            # Warn about resting orders\n            resting = [t for t in successful_trades if t.get(\"resting\")]\n            if resting:\n                self.callbacks.warn(\n                    f\"{len(resting)} order(s) resting on book. \"\n                    \"Run 'cc-liquid apply-stops' after they fill to add protection.\"\n                )\n\n    return {\n        \"successful_trades\": successful_trades,\n        \"all_trades\": trades,\n        \"stop_loss_result\": sl_result\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_account_value","title":"<code>get_account_value()</code>","text":"<p>Retrieves the total account value in USD.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_account_value(self) -&gt; float:\n    \"\"\"Retrieves the total account value in USD.\"\"\"\n    user_state = self.get_user_state()\n    return float(user_state[\"marginSummary\"][\"accountValue\"])\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_fee_summary","title":"<code>get_fee_summary()</code>","text":"<p>Get fee rates and trading volume statistics.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing fee rates (maker/taker), volume stats, and fee schedule</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_fee_summary(self) -&gt; dict[str, Any]:\n    \"\"\"Get fee rates and trading volume statistics.\n\n    Returns:\n        Dictionary containing fee rates (maker/taker), volume stats, and fee schedule\n    \"\"\"\n    owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n    if not owner:\n        raise ValueError(\"Missing portfolio owner address\")\n    return self.info.user_fees(owner)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_fill_history","title":"<code>get_fill_history(start_time=None, end_time=None)</code>","text":"<p>Get fill history with optional time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | None</code> <p>Unix timestamp in milliseconds (optional)</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>Unix timestamp in milliseconds (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of fills with execution details, prices, sizes, and fees</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_fill_history(\n    self, start_time: int | None = None, end_time: int | None = None\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get fill history with optional time range.\n\n    Args:\n        start_time: Unix timestamp in milliseconds (optional)\n        end_time: Unix timestamp in milliseconds (optional)\n\n    Returns:\n        List of fills with execution details, prices, sizes, and fees\n    \"\"\"\n    owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n    if not owner:\n        raise ValueError(\"Missing portfolio owner address\")\n\n    if start_time is not None:\n        return self.info.user_fills_by_time(owner, start_time, end_time)\n    return self.info.user_fills(owner)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_open_orders","title":"<code>get_open_orders()</code>","text":"<p>Get current open orders.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of open orders with details like coin, size, limit price, side, etc.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_open_orders(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get current open orders.\n\n    Returns:\n        List of open orders with details like coin, size, limit price, side, etc.\n    \"\"\"\n    owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n    if not owner:\n        raise ValueError(\"Missing portfolio owner address\")\n    return self.info.open_orders(owner)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_portfolio_info","title":"<code>get_portfolio_info()</code>","text":"<p>Get complete portfolio information as structured data.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_portfolio_info(self) -&gt; PortfolioInfo:\n    \"\"\"Get complete portfolio information as structured data.\"\"\"\n    try:\n        user_state = self.get_user_state()\n    except Exception as e:\n        self.logger.warning(f\"Could not get user state: {e}\")\n        # Return empty portfolio if we can't connect\n        return PortfolioInfo(\n            account=AccountInfo(\n                account_value=0,\n                total_position_value=0,\n                margin_used=0,\n                free_collateral=0,\n                cash_balance=0,\n                withdrawable=0,\n                current_leverage=0,\n            ),\n            positions=[],\n        )\n\n    margin_summary = user_state.get(\"marginSummary\", {}) if user_state else {}\n    all_mids = self.info.all_mids() if user_state else {}\n\n    # Build account info\n    account_info = AccountInfo(\n        account_value=float(margin_summary.get(\"accountValue\", 0)),\n        total_position_value=float(margin_summary.get(\"totalNtlPos\", 0)),\n        margin_used=float(margin_summary.get(\"totalMarginUsed\", 0)),\n        free_collateral=float(margin_summary.get(\"accountValue\", 0))\n        - float(margin_summary.get(\"totalMarginUsed\", 0)),\n        cash_balance=float(margin_summary.get(\"totalRawUsd\", 0)),\n        withdrawable=float(user_state.get(\"withdrawable\", 0)),\n        current_leverage=float(margin_summary.get(\"totalNtlPos\", 0))\n        / float(margin_summary.get(\"accountValue\", 1))\n        if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n        else 0,\n        raw_margin_summary=margin_summary,\n    )\n\n    # Add cross margin info if available\n    cross_margin = user_state.get(\"crossMarginSummary\")\n    if cross_margin:\n        account_info.cross_leverage = (\n            float(cross_margin.get(\"accountValue\", 0))\n            / float(margin_summary.get(\"accountValue\", 1))\n            if float(margin_summary.get(\"accountValue\", 0)) &gt; 0\n            else 0\n        )\n        account_info.cross_margin_used = float(\n            cross_margin.get(\"totalMarginUsed\", 0)\n        )\n        account_info.cross_maintenance_margin = float(\n            cross_margin.get(\"totalMaintenanceMargin\", 0)\n        )\n        account_info.raw_cross_margin_summary = cross_margin\n\n    # Build positions list\n    positions = []\n    for position_data in user_state.get(\"assetPositions\", []):\n        pos = position_data.get(\"position\", {})\n        size = float(pos.get(\"szi\", 0))\n\n        if size == 0:\n            continue\n\n        coin = pos[\"coin\"]\n        entry_px = float(pos.get(\"entryPx\", 0))\n        mark_px = float(all_mids.get(coin, entry_px))\n        position_value = abs(size * mark_px)\n\n        # Calculate unrealized PnL\n        if size &gt; 0:\n            unrealized_pnl = (mark_px - entry_px) * size\n            side = \"LONG\"\n        else:\n            unrealized_pnl = (entry_px - mark_px) * abs(size)\n            side = \"SHORT\"\n\n        return_pct = (\n            (unrealized_pnl / (abs(size) * entry_px) * 100) if entry_px &gt; 0 else 0\n        )\n\n        positions.append(\n            Position(\n                coin=coin,\n                side=side,\n                size=abs(size),\n                entry_price=entry_px,\n                mark_price=mark_px,\n                value=position_value,\n                unrealized_pnl=unrealized_pnl,\n                return_pct=return_pct,\n                liquidation_price=float(pos[\"liquidationPx\"])\n                if \"liquidationPx\" in pos and pos[\"liquidationPx\"] is not None\n                else None,\n                margin_used=float(pos[\"marginUsed\"])\n                if \"marginUsed\" in pos and pos[\"marginUsed\"] is not None\n                else None,\n            )\n        )\n\n    return PortfolioInfo(account=account_info, positions=positions)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_positions","title":"<code>get_positions()</code>","text":"<p>Retrieves the user's open positions as a dict.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_positions(self) -&gt; dict[str, Any]:\n    \"\"\"Retrieves the user's open positions as a dict.\"\"\"\n    user_state = self.get_user_state()\n    positions = {}\n    for position_data in user_state.get(\"assetPositions\", []):\n        position = position_data.get(\"position\", {})\n        if float(position.get(\"szi\", 0)) != 0:\n            positions[position[\"coin\"]] = position\n    return positions\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.get_user_state","title":"<code>get_user_state()</code>","text":"<p>Retrieves the current state of the user's account.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def get_user_state(self) -&gt; dict[str, Any]:\n    \"\"\"Retrieves the current state of the user's account.\"\"\"\n    # Always query Info using the portfolio owner: vault (if set) or master address.\n    # Never use the agent/signer address for Info, as it has no balances.\n    owner = self.config.HYPERLIQUID_VAULT_ADDRESS or self.config.HYPERLIQUID_ADDRESS\n    if not owner:\n        raise ValueError(\n            \"Missing portfolio owner. Set HYPERLIQUID_VAULT_ADDRESS or HYPERLIQUID_ADDRESS.\"\n        )\n    return self.info.user_state(owner)\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.load_state","title":"<code>load_state()</code>","text":"<p>Public wrapper to load last rebalance timestamp.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def load_state(self) -&gt; datetime | None:\n    \"\"\"Public wrapper to load last rebalance timestamp.\"\"\"\n    return self._load_state()\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.plan_close_all_positions","title":"<code>plan_close_all_positions(*, force=False)</code>","text":"<p>Plan to close all open positions (return to cash) without executing orders.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def plan_close_all_positions(self, *, force: bool = False) -&gt; dict:\n    \"\"\"Plan to close all open positions (return to cash) without executing orders.\"\"\"\n    current_positions = self.get_positions()\n\n    if not current_positions:\n        self.callbacks.info(\"No open positions to close.\")\n        return {\n            \"target_positions\": {},\n            \"trades\": [],\n            \"skipped_trades\": [],\n            \"account_value\": self.get_account_value(),\n            \"leverage\": self.config.portfolio.target_leverage,\n        }\n\n    self.callbacks.info(\"Closing all positions to return to cash...\")\n\n    # Create target positions of 0 for all current positions\n    target_positions = {coin: 0 for coin in current_positions.keys()}\n    trades, skipped_trades = self._calculate_trades(\n        target_positions, current_positions, force=force\n    )\n\n    account_value = self.get_account_value()\n    leverage = self.config.portfolio.target_leverage\n    return {\n        \"target_positions\": target_positions,\n        \"trades\": trades,\n        \"skipped_trades\": skipped_trades,\n        \"account_value\": account_value,\n        \"leverage\": leverage,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.plan_rebalance","title":"<code>plan_rebalance(predictions=None)</code>","text":"<p>Compute a rebalancing plan without executing orders.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def plan_rebalance(self, predictions: pl.DataFrame | None = None) -&gt; dict:\n    \"\"\"Compute a rebalancing plan without executing orders.\"\"\"\n    # Check for open orders (warning if present)\n    open_orders = self.get_open_orders()\n    if open_orders:\n        self.callbacks.warn(\n            f\"Found {len(open_orders)} open order(s). These may conflict with rebalancing.\"\n        )\n    # Load predictions if not provided\n    if predictions is None:\n        self.callbacks.info(\"Loading predictions...\")\n        predictions = self._load_predictions()\n\n        if predictions is None or predictions.is_empty():\n            self.callbacks.error(\"No predictions available, cannot rebalance\")\n            return {\n                \"target_positions\": {},\n                \"trades\": [],\n                \"skipped_trades\": [],\n                \"account_value\": 0.0,\n                \"leverage\": self.config.portfolio.target_leverage,\n                \"open_orders\": open_orders,\n            }\n\n        # Display prediction info\n        unique_assets = predictions[self.config.data.asset_id_column].n_unique()\n        latest_data = predictions[self.config.data.date_column].max()\n        self.callbacks.info(\n            f\"Loaded predictions for {unique_assets} assets (latest: {latest_data})\"\n        )\n\n    # Asset Selection, Position Calculation, and Trade Generation\n    target_positions = self._get_target_positions(predictions)\n    current_positions = self.get_positions()\n    trades, skipped_trades = self._calculate_trades(\n        target_positions, current_positions\n    )\n\n    # Build plan (including skipped trades)\n    account_value = self.get_account_value()\n    leverage = self.config.portfolio.target_leverage\n    return {\n        \"target_positions\": target_positions,\n        \"trades\": trades,\n        \"skipped_trades\": skipped_trades,\n        \"account_value\": account_value,\n        \"leverage\": leverage,\n        \"open_orders\": open_orders,\n    }\n</code></pre>"},{"location":"api/python/#cc_liquid.trader.CCLiquid.save_state","title":"<code>save_state(last_rebalance_date)</code>","text":"<p>Public wrapper to persist last rebalance timestamp.</p> Source code in <code>src/cc_liquid/trader.py</code> <pre><code>def save_state(self, last_rebalance_date: datetime) -&gt; None:\n    \"\"\"Public wrapper to persist last rebalance timestamp.\"\"\"\n    self._save_state(last_rebalance_date)\n</code></pre>"},{"location":"api/python/#callback-protocols","title":"Callback protocols","text":""},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks","title":"<code>CCLiquidCallbacks</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for trader callbacks to abstract UI/UX concerns.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>class CCLiquidCallbacks(Protocol):\n    \"\"\"Protocol for trader callbacks to abstract UI/UX concerns.\"\"\"\n\n    # High-level lifecycle methods\n    def ask_confirmation(self, message: str) -&gt; bool:\n        \"\"\"Ask user for confirmation.\"\"\"\n        ...\n\n    def info(self, message: str) -&gt; None:\n        \"\"\"Display info message.\"\"\"\n        ...\n\n    def warn(self, message: str) -&gt; None:\n        \"\"\"Display warning message.\"\"\"\n        ...\n\n    def error(self, message: str) -&gt; None:\n        \"\"\"Display error message.\"\"\"\n        ...\n\n    def on_config_override(self, overrides: list[str]) -&gt; None:\n        \"\"\"Display applied configuration overrides.\"\"\"\n        ...\n\n    # Trade execution progress hooks\n    def on_trade_start(self, idx: int, total: int, trade: dict[str, Any]) -&gt; None:\n        \"\"\"Called when a trade execution starts.\"\"\"\n        ...\n\n    def on_trade_fill(\n        self, trade: dict[str, Any], fill_data: dict[str, Any], slippage_pct: float\n    ) -&gt; None:\n        \"\"\"Called when a trade is filled.\"\"\"\n        ...\n\n    def on_trade_fail(self, trade: dict[str, Any], reason: str) -&gt; None:\n        \"\"\"Called when a trade fails.\"\"\"\n        ...\n\n    def on_batch_complete(self, success: list[dict], failed: list[dict]) -&gt; None:\n        \"\"\"Called when a batch of trades completes.\"\"\"\n        ...\n\n    def show_trade_plan(\n        self,\n        target_positions: dict,\n        trades: list,\n        account_value: float,\n        leverage: float,\n    ) -&gt; None:\n        \"\"\"Display the trade plan before execution.\"\"\"\n        ...\n\n    def show_execution_summary(\n        self,\n        successful_trades: list[dict],\n        all_trades: list[dict],\n        target_positions: dict,\n        account_value: float,\n    ) -&gt; None:\n        \"\"\"Display execution summary after trades complete.\"\"\"\n        ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.ask_confirmation","title":"<code>ask_confirmation(message)</code>","text":"<p>Ask user for confirmation.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def ask_confirmation(self, message: str) -&gt; bool:\n    \"\"\"Ask user for confirmation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.error","title":"<code>error(message)</code>","text":"<p>Display error message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def error(self, message: str) -&gt; None:\n    \"\"\"Display error message.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.info","title":"<code>info(message)</code>","text":"<p>Display info message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def info(self, message: str) -&gt; None:\n    \"\"\"Display info message.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_batch_complete","title":"<code>on_batch_complete(success, failed)</code>","text":"<p>Called when a batch of trades completes.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_batch_complete(self, success: list[dict], failed: list[dict]) -&gt; None:\n    \"\"\"Called when a batch of trades completes.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_config_override","title":"<code>on_config_override(overrides)</code>","text":"<p>Display applied configuration overrides.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_config_override(self, overrides: list[str]) -&gt; None:\n    \"\"\"Display applied configuration overrides.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_fail","title":"<code>on_trade_fail(trade, reason)</code>","text":"<p>Called when a trade fails.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_fail(self, trade: dict[str, Any], reason: str) -&gt; None:\n    \"\"\"Called when a trade fails.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_fill","title":"<code>on_trade_fill(trade, fill_data, slippage_pct)</code>","text":"<p>Called when a trade is filled.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_fill(\n    self, trade: dict[str, Any], fill_data: dict[str, Any], slippage_pct: float\n) -&gt; None:\n    \"\"\"Called when a trade is filled.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.on_trade_start","title":"<code>on_trade_start(idx, total, trade)</code>","text":"<p>Called when a trade execution starts.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def on_trade_start(self, idx: int, total: int, trade: dict[str, Any]) -&gt; None:\n    \"\"\"Called when a trade execution starts.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.show_execution_summary","title":"<code>show_execution_summary(successful_trades, all_trades, target_positions, account_value)</code>","text":"<p>Display execution summary after trades complete.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def show_execution_summary(\n    self,\n    successful_trades: list[dict],\n    all_trades: list[dict],\n    target_positions: dict,\n    account_value: float,\n) -&gt; None:\n    \"\"\"Display execution summary after trades complete.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.show_trade_plan","title":"<code>show_trade_plan(target_positions, trades, account_value, leverage)</code>","text":"<p>Display the trade plan before execution.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def show_trade_plan(\n    self,\n    target_positions: dict,\n    trades: list,\n    account_value: float,\n    leverage: float,\n) -&gt; None:\n    \"\"\"Display the trade plan before execution.\"\"\"\n    ...\n</code></pre>"},{"location":"api/python/#cc_liquid.callbacks.CCLiquidCallbacks.warn","title":"<code>warn(message)</code>","text":"<p>Display warning message.</p> Source code in <code>src/cc_liquid/callbacks.py</code> <pre><code>def warn(self, message: str) -&gt; None:\n    \"\"\"Display warning message.\"\"\"\n    ...\n</code></pre>"}]}